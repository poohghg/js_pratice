JavaScript 통합 정리본

기본적인 JavaScript 문법을 정리해보자.

---

## 목차

[TOC]

---

정리 참조 사이트.

- https://developer.mozilla.org/ko/docs/Learn/JavaScript/First_steps/What_is_JavaScript
  - Mdn 공식문서
- https://ko.javascript.info/
- https://github.com/yjs03057/33-js-concepts
- https://velog.io/@jakeseo_me/series/33conceptsofjavascript

___



### 0.자바스크립트 이벤트 루프

JavaScript의 런타임 모델은 코드의 실행, 이벤트의 수집과 처리, 큐에 대기 중인 하위 작업을 처리하는 **이벤트 루프**에 기반하고 있으며, C 또는 Java 등 다른 언어가 가진 모델과는 상당히 다르다.

<img src="https://blog.kakaocdn.net/dn/bOhai3/btq0zvN3hr9/HgHmRabY6HhLd24pfDIHd1/img.png" alt="img" style="zoom: 67%;" />



- **콜스택**: 자바스크립트에서 수행해야 할 함사둘을 순차적으로 스택에 담아 처리
- **힙**: 객체는 힙에 할당됩니다. 힙은 단순히 메모리의 큰 (그리고 대부분 구조화되지 않은) 영역을 지칭하는 용어
- **Web** API: 웹 브라우저에서 제공하는 API로 AJAX나 Timeout등의 비동기 작업을 실행
  - 위 요청은 **Web** API에서 처리되며, 처리된후 콜백함수는 순차적으로 콜백큐에 쌓이게 된다. 
- **콜백큐**: JavaScript 런타임은 메시지 큐, 즉 처리할 메시지의 대기열을 사용합니다. 각각의 메시지에는 메시지를 처리하기 위한 함수가 되어있음.
- **Event Loop**: Call Stack이 비어있다면 Task Queue의 작업을 Call Stack으로 옮김

일반적으로 자바스크립트 엔진은 단일 호출 스택을 사용하며,해당 요청을 순차적으로 콜 스택에 담아 처리한다. 이때 비동기 호출(동시처리)은 구동환경에 따라 브라우저(Web API)또는 Node.js가 처리하게 된다.일반적으로 브라우저에서 수행하는 ajax,Dom조작,Timer등은 자바스크립트엔진이 아닌 Wep API에서 처리되어 콜백큐에 순차적으로 쌓이고 요청 순서에 따라 이벤트루프를 통해 콜 스택에 쌓이게 된다.

```javascript
// 출처 https://meetup.toast.com/posts/89
function delay() {
    for (var i = 0; i < 100000; i++);
}
function foo() {
    delay();
    bar();
    console.log('foo!'); // (3)
}
function bar() {
    delay();
    console.log('bar!'); // (2)
}
function baz() {
    console.log('baz!'); // (4)
}

setTimeout(baz, 10); // (1)
foo();
```

- 다음 코드의 로그는 다음순으로 찍힌다. 'bar!' -> 'foo!' -> 'baz!
- 위의 코드에서 setTimeout의 콜백함수는 일반적으로 10초후에 실행을 보장하지 않는다.
  - 이는 단순히 Web API가 10초를 기다린후 콜백큐에 콜백함수를 전달하는 시간이다.
  - 순차적으로 콜백큐에 쌓인 이벤트들은 순차적으로 콜 스택이 비어있을때 처리된다.



참고

___

비동기 for

https://velog.io/@hanameee/%EB%B0%B0%EC%97%B4%EC%97%90-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%9E%91%EC%97%85%EC%9D%84-%EC%8B%A4%EC%8B%9C%ED%95%A0-%EB%95%8C-%EC%95%8C%EC%95%84%EB%91%90%EB%A9%B4-%EC%A2%8B%EC%9D%84%EB%B2%95%ED%95%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0%EB%93%A4#for-%EB%AC%B8%EC%9C%BC%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95

> #### 출처
>
> https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop
>
> https://meetup.toast.com/posts/89



------

### 0_1.브라우저 렌더링 과정

브라우저의 핵심 기능은 필요한 리소스(HTML,CSS,자바스크립트,이미지,폰트)등의 정적 파일 또는 동적으로 생성한 데이터를 서버에 요청하고 응답 받아 브라우저에 시각적으로 렌더링하는 것이다.

- 브라우저의 주소창에 URL 입력 -> 호스트 이름이 DNS를 통해 IP주소로 변환 -> 이 주소를 갖는 서버에게 요청을 전송

> 1. **사용자가 웹 브라우저를 통해 google.com 을 입력하면 URL 주소 중 도메인 네임 부분을 [DNS](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-dns) 서버에서 검색합니다.**
> 2. **DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 [URL](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-url) 정보와 함께 전달합니다.**
> 3. **브라우저는 [HTTP](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-http) [프로토콜](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-프로토콜)을 사용하여 요청 메시지를 생성하고 HTTP 요청 메시지는 [TCP](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-tcp)/[IP](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-ip) 프로토콜을 사용하여 서버로 전송됩니다.**
> 4. **서버는 [response](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-response) 메시지를 생성하여 다시 브라우저에게 데이터를 전송합니다.**
> 5. **브라우저는 response를 받아 [파싱](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-파싱)하여 화면에 [렌더링](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-렌더링)합니다.**
>
> 참조
>
> https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md

- DNS(**Domain Name System**): 도메인 이름 시스템은 사용자가 입력한 도메인을 머신이 읽을 수 있는 IP주소로 변환하는 시스템이다.
- URL(Uniform Resource Locator): URL은 통합 자원 지시자로 인터넷의 리소스를 가르키는 표준명칭으로 서버의 자원을 요청할때 사용된다.URL을 통해 인터넷 상의 모든 리소스를 요청할 수 있으며, HTTP, FTP 등의 자원 요청도 가능합니다.
- HTTP(HyperText Transfer Protocol): HTTP는 TCP기반의 클라이언트와 서버 사이에 이루어지는 요청/응답 프로토콜이다.HTTP는 Text Protocol로 사람이 쉽게 읽고 쓸 수 있습니다. 프로토콜 설계상 클라이언트가 요청을 보내면 반드시 응답을 받아야 합니다. 응답을 받아야 다음 request를 보낼 수 있습니다.
- TCP:TCP (**T**ransmission **C**ontrol **P**rotocol)은 두 개의 호스트를 연결하고 데이트 스트림을 교환하게 해주는 중요한 네트워크 프로토콜이다. TCP는 데이터 전송을 제어하고 데이터를 어떻게 보낼지, 어떻게 맞출지를 정한다.또한 데이터와 패킷이 보내진 순선대로 전달 하는 것을 보장해준다.신뢰성과 연결성을 책임지기 위한 프로토콜이며, 호스트와 호스트간의 데이터 전송은 IP(인터넷 계층 프로토콜)에 의지하면서 동시에 신뢰성 있는 전송에 대해서는 TCP가 책임지는 구조입니다.

#### 1.DOM생성

- DOM(Document Object Model)이란?
  - **웹페이지를 프로그래밍적으로 제어할 수 있게 해주는 객체모델** 이다. 
  - 문서 객체란 html, head, body와 같은 태그들을 javascript가 이용할 수 있는 (메모리에 보관할 수 있는) 객체를 의미합니다. DOM은 HTML과 스크립팅 언어(JavaScript)를 서로 이어주는 역할을 합니다
- BOM(Browser Object Model)이란?
  - **브라우저의 창이나 프레임을 프로그래밍적으로 제어할 수 있게 해주는 객체모델** 이다. 이를 통해서 브라우저의 새 창을 열거나 다른 문서로 이동하는 등의 기능을 실행시킬 수 있다. 전역객체로 `window` 가 있으며 하위 객체들로 `location` , `navigator` , `document` , `screen` , `history` 가 포함되어 있다.



파싱은 하나의 프로그램을 런타임 환경이 실제로 실행할 수 있는 내부 포멧으로 분석하고 변환하는 것을 의미한다.즉 파싱은 문서의 내용을 토큰으로 분석하고, 문법적 의미와 구조를 반영한 파스 트리(parse tree)를 생성하는 과정이다.

HTML 파싱과 생성 -> DOM생성

- HTML 문서는 문자열로 이루어진 순수한 텍스트다.
- HTML 문서는 바이트 -> 문자 -> 토큰 -> 노드 -> DOM 위 과정을 통해 브라우저가 이해 할 수 있는 자료구조인 DOM으로 변환된다.

CSS 파싱과 생성 -> CSSOM생성

- 렌더링 엔진은 DOM을 생성해 나가다가 CSS를 도르하는 코드를 만나면 DOM생성을 일시 중단하고 CSS파일을 서버에 요청한다.
- 바이트 -> 문자 -> 토큰 -> 노드 -> CSSOM을 생성한다.

#### 2.렌더 트리 구축

DOM 트리와 CSSOM 트리가 생성되면, 이 둘을 연결하여 표시해야 할 순서로 내용을 그려낼 수 있도록 하기 위해 렌더 트리를 생성한다.

렌더 트리는 렌더링을 위한 트르 구조의 자료구조이다. 따라서 화면에 랜더링되지 않는 노드(meta)와 css(display:none)에 의해 비표시되는 노드들은 포함되지 않는다.

**즉. 렌더트리는 브라우저 화면에 렌더링되는 노드만으로 구성된다.**(실제 페이지에서 사용되는 노드만을 포함)

<img src="https://cresumerjang.github.io/2019/06/24/critical-rendering-path/oldBrowserRenderFlow.png" alt="웹 브라우저는 렌더링 프로세스" style="zoom: 25%;" />



#### 3.레이아웃

렌더링 트리는 계산된 스타일만을 연결한 것이지 화면상 어디에 위치할지를 계산한 것은 아니다.즉 완성된렌더 트리는 각 HTML 요소의 레이아웃(실제 위치와 크기)을 계산하는데 사용되며 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 입력된다.

#### 4.페인트

이전 레이아웃 단계에서 계산된 값을 이용해 렌더트리의 각 노드를 화면상의 실제 픽셀로 변환한다. 이때 위치와 관계없는 CSS 속성(색상, 투명도 등)을 적용한다. 그리고 픽셀로 변환된 결과는 포토샵의 레이어처럼 생성되어 개별 레이어로 관리된다.[`transform`](https://developer.mozilla.org/ko/docs/Web/CSS/transform) 속성 등을 사용하면 엘리먼트가 레이어화 되는데, 이 과정을 페인트라고 한다.

**!!브라우저 렌더링 과정은 반복해서 실행 될수 있다.**

- 자바스크립트에 의한 노드 추가 또는 삭제
- 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
- 레이아웃의 변경을 발생시키는 스타일의 변경
- 페이지 초기 렌더링시
- 폰트 변경과 이미지 크기변환

#### 5.리플로우와 리페인트

자바스크립트코드에 의해 DOM API가 사용된 경우 CSSOM 이나 DOM이 변경된다.

이때 변경된 CSSOM 이나 DOM은 다시 렌더트리로 결합되고 변경된 렌더트리를 기반으로 레이아웃과 페인트 과정을 거쳐 다시 렌더링된다.

##### 리플로우: 레이아웃 계산을 다시하는 것을 말한다. 노드의 추가,삭제,요소의 크기,위치 변경 원도우 리사이즈 등으로 발생한다.

- Dom추가/삭제
- css속성 변경을 통해 기하학적인(높이/넢입/위치 등) 변화
- 레이아웃을 변경시키는 css속성 :`margin`,`padding`,`height`, `width`, `left`, `top`, `font-size`, `line-height` 등

##### 리페인트: 재결합된 렌더 트리를 기반으로 다시 페인트를 하는것을 말한다.

- Css 속성 변경이 기하학적 변화가 발생하이 않는 경우
- 레이아웃을 변경시키지 않는 css속성:`background-color`, `color`, `visibility`, `text-decoration`

리플로우와 리페인트는 순차적으로 실행되지 않는다, 만약 레이아웃에 영향을 미치지 않는다면 리페인트만 일이넌다.

### 5_1 합성(Compositing)

화면에 표시를 위해 페이지에서 페인트된 부분을 합치는 과정이다.

`tranform` `opacity` `will-change` 등을 사용했을 때 합성 과정을 거친다.

#### 6.최적화

- 브라우저는 `렌더링 과정`에서 성능을 제일 많이 잡아먹는다.
- 특히 `Reflow`가 순간적으로 많이 발생할 경우 치명적이다.

페이지 로드 최적화

- 블록 차단 리소스 최적화
- 번들 모듈 사용
- 트리 쉬에킹
  - 외부 모듈에서 필요한 기능만을 임포트
- 웹폰트 최적화
  - 필요한 리소스만 초기 로딩 
  - Woff2 형식사용
- 이미지 최적화
  - 이미지 스프라이트
    - 이미지를 하나로 묶어 한번의 리소스를 요청
  - 지연로딩

#### 페이지 렌더링

- 불필요한 강제동기식 레이아웃과 레이아웃 스레싱 피하기
- 상위 DOM의 변화보다 하위DOM를 변화시키자
  - 상위 요소의 높이 넓이고정
- display :node 속성은 레이아웃이 발생하지 않는다.
- 애니메이션 요소는 포지션을 고정한다 -> 고정된 포지션은 레이아웃에 영향을 미치지 않는다.
- 리페인트를 일으키는 속성을 사용
  - transform 속성을 활용하면 엘레멘트 레이어만 분리하여 합성만 일어나게 된다.

> 출처
>
> https://coffeeandcakeandnewjeong.tistory.com/34
>
> https://ui.toast.com/fe-guide/ko_PERFORMANCE
>
> https://velog.io/@wiostz98kr/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95%EA%B3%BC-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95
>
> 
>
> 브라우저 렌더링 최적화 과정
>
> https://velog.io/@bumsu0211/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95%EA%B3%BC-%EC%B5%9C%EC%A0%81%ED%99%94
>
> https://junilhwang.github.io/TIL/Javascript/Design/Vanilla-JS-Virtual-DOM/#_1-reflow-repaint
>
> requestAnimationFrame
>
> https://darrengwon.tistory.com/641

------

### 0_2 모듈 번들러와 트랜스파일러

#### 모듈 번들러

- 모듈이란? 모듈은 여러 기능들에 관한 코드가 모여있는 하나의 파일로 다음과 같은 것들을 위해 사용된다.
  - 유지보수성: 기능들이 모듈화가 잘 되어있다면, 의존성을 그만큼 줄일 수 있기 때문에 어떤 기능을 개선한다거나 수정할 때 훨씬 편하게 할 수 있다.
  - 네임스페이스화:자바스크립트에서 전역변수는 전역공간을 가지기 때문에 코드의 양이 많아질수록 겹치는 네임스페이스가 많아질 수 있다. 그러나 모듈로 분리하면 모듈만의 네임스페이스를 갖기 때문에 그 문제가 해결된다.
  - 재사용성:똑같은 코드를 반복하지 않고 모듈로 분리시켜서 필요할 때마다 사용할 수 있다.



현대의 프로튼엔드 개발은 모듈단위로 파일을 엮어서 개발하는 방식이다.즉, 모듈은 서로 의존성을 띄고 있는데 이런점에서 다음과 같은 문제점이 발생할 수 있다.

- 수많은 모듈들의 순서를 어떻게 처리할 것인가?(의존성 처리)
- 모듈들이 많아질수로 HTTP요청이 많아질텐데 이로 인한 오버헤드는 어떻게 해결할 거인가?
- ES6+ 스펙의 코드를 어떻게 처리할 것인가?

위 문제들을 해결하기 위해 등장한 것이 모듈번들러로 각각의 모듈 의존성을 해결하여 하나의 자바스크립트 파일로 만드는 도구이다.이미지 압축,최소화 등의 여러가지 기능등도 제공하며 대표적인 번들러로는 Webpack, Parcel, Rollup 등이 있다.



일반적으로 웹팩은 파일을 번들화(여러파일을 하나의 파일로 묶어줌)하고,빌드하고,종합하는 도구이다.

- 웹팩에 묶인 코드들은 일반적으로 최적화된다.
- 빌드절차를 쉽게 해준다
- 추가 빌드툴을 제공한다.

#### Loaders

webpack은 기본적으로 JavaScript와 JSON 파일만 이해합니다. **로더를** 사용하면 webpack이 다른 유형의 파일을 처리하거나, 그들을 유효한 [모듈](https://webpack.kr/concepts/modules)로 변환 하여 애플리케이션에서 사용하거나 디펜던시 그래프에 추가합니다.

- 로더는 웹팩에게 특정파일을 어떻게 다룰지를 전달해주는 패키지이다.

#### 트랜스 파일러

트랜스파일링(Transpiling)이란 특**정 언어로 작성된 코드를 비슷한 다른 언어로 변환시키는 행위** 를 말하며 이를 해주는 것이 트랜스파일러(Transpiler)이다. 트랜스파일러가 필요한 이유는 모든 브라우저가 ES6+의 기능을 제공하지 않기 때문에 이를 ES5 코드로 변환시키는 과정이 필요하다. 트랜스파일러는 이 작업을 수행해준다. 사실 ES6+의 기능 뿐만 아니라 리액트의 JSX를 자바스크립트 코드로 변환시킨다거나 타입스크립트를 자바스크립트로 변환시키는 등의 역할도 트랜스파일러의 기능 중에 하나이다. ES6+나 JSX를 변환시키는 트랜스파일러로는 바벨(Babel)이 있으며 타입스크립트를 변환시키는 도구로는 타입스크립트 트랜스파일러가 있다. 보통 프론트엔드 프레임워크 및 라이브러리를 사용해서 개발할 때 모듈 번들러에 트랜스파일러를 추가해서 사용하는 방식을 사용한다.



------

### 0_3.브라우저 저장소

Web Storage란 HTML5부터 제공하는 기능으로,해당 도메인과 관련된 특정 데이터를 서버가 아니라 클라이언트 웹브라우저에 저장할 수 있도록 제공하는 기능이다. 키/값 쌍으로 저장하고, 키를 기반으로 데이터를 조회한다.영구저장소(LocalStorage)와 임시저장소(SessionStorage)를 따로 두어 데이터의 지속성을 구분할 수 있어 응용 환경에 맞는 선택이 가능하다.

LocalStorage: 브라우저를 닫았다가 다시 열어도 데이터가 유지된다.

SessionStorage: 브라우저가 열려있는 한 페이지를 Reload해도 계속 유지된다. 하지만 브라우저를 닫으면 삭제된다.

Web Storage는 쿠기와 마찬가지로 사이트의 도메인 단위로 접근이 제한된다.예를들어 A도메인에서 저장한 데이터는 B도메인에서 조회할 수 없다.이는 데이터 보안 측면에서 당연하다.

쿠기와 웹스토리지 **<u>모두 브라우저에 저장</u>**되지만 쿠키는 아래와 같은 단점이 있다.

- 4KB의 데이터 저장 제한
- HTTP Request에 암호화 되지 않은 상태로 사용하기 때문에 보안에 취약하다.
- 쿠키는 모든 HTTP Request에 포함되어 있어 웹서비스 성능에 영향을 줄 수 있다.

> ### Web Storage와 Cookie의 비교
>
> #### 쿠키는 매번 서버로 전송된다.
>
> 웹사이트에서 쿠키를 설정하면 이후 모든 웹 요청은 쿠키정보를 포함해 서버로 전송된다. **Web Storage는 저장된 데이터가 클라이언트에 존재할 뿐 서버로 전송되지는 않는다.** 이는 **네트워크 트래픽 비용을 줄여준다.**
>
> #### Web Storage는 단순 문자열을 넘어(스크립트) 객체정보를 저장할 수 있다.
>
> 문자열 기반 데이터 외에 체계적으로 **구조화된 객체를 저장**할 수 있다. 이는 개발 편의성을 제공해주는 장점이다. (단, 브라우저의 지원 여부를 확인해봐야 한다.)
>
> #### Web Storage는 용량의 제한이 없다.
>
> 쿠키는 개수와 용량에 제한이 있다. 클라이언트에 최대 300개의 쿠키를 저장할 수 있으며, 하나의 사이트(도메인)에서는 최대 20개를 저장할 수 있다. 또한, 하나의 쿠키값은 최대 4KB로 제한되어 있다.
> 그러나 Web Storage에는 제한이 없다. 쿠키도 하위키를 이용하면 이러한 제한을 일부 해소할 수는 있으나, 대용량으로 쿠키를 저장할 일은 없다.
>
> #### Web Storage는 영구 데이터 저장이 가능하다.
>
> 쿠키는 만료일자를 지정하게 되어있어 언젠가 제거된다. 만약 만료일자를 지정하지 않으면 **✔️세션 쿠키**가 된다. 만일 영구 쿠키를 원한다면 만료일자를 굉장히 멀게 설정하여 해결할 수 있다.
> Web Storage는 만료기간의 설정이 없다. 즉, 한 번 저장한 데이터는 영구적으로 존재하게 된다.
>
> ------
>
> ✔️ **세션쿠키(Session Cookie)**
> 활성 웹 브라우저 세션이 있는 기간동안 저장된다. 세션쿠키는 일반적으로 웹 브라우저를 닫을 때 삭제된다.
> ✔️ **영구쿠키/지속적쿠키(Persistent Cookie)**
> 각 쿠키에 지정된 기간동안 또는 장치에서 쿠키를 수동으로 삭제할 때까지 장치에 남아있는다.

### 0_4.세선 vs JWT

> ###  세션이란?
>
> - 세션은 HTTP의 stateless 속성을 보완한다는 점에서 쿠키와 자주 비교되곤 한다. 쿠키의 유형에는 영구 쿠키와 세션 쿠키가 있어 만료시기가 각각 다르지만 <u>세션은 대부분의 경우 브라우저 종료 시 만료된다</u>. 쿠키와 세션의 가장 큰 차이는 저장 위치이다. <u>쿠키는 클라이언트에 저장되고</u>, <u>세션은 서버에 저장된다</u>. 그러나 서로 반대 되는 개념이 아니라 세션 id를 쿠키에 담아서 통신한다는 점에서 세션은 쿠키를 사용하는 방식이라고 볼 수 있다. 쿠키에 로그인에 대한 정보를 담는다면 클라이언트에 노출 되어 위험하기 때문에 서버에 저장하는 방식으로 세션을 사용한다.
> - 세션의 단점
>   - 세션기반 인증 방식을 사용할 때 중앙 세션 관리 시스템에서 하나의 문제가 시스템 전체로 확산된다는 문제
>   - 사용자가 많아짐에 따라 세션 DB와 서버를 확장해야 한다는 점이다. 

jwt이란? 다. JWT는 JSON Web Token의 약자로 이상한 형태의 문자열이다.

- JWT는 암호화되지 않아서 누구나 확인할 수 있기 때문에 중요한 정보를 JWT에 담으면 안된다.

동작방식?

- 쉽게 설명하자면 JWT는 일종의 확인서이다. 우리가 어떤 웹사이트에 로그인을 해서 성공적으로 Authentication이 이루어지면 서버는 사인된 확인서(JWT)를 우리에게 제공한다. 그러면 앞으로 요청 때마다 JWT를 서버에게 같이 보여주면서 권한을 확인받는 것이다. 서버는 JWT만 확인해 Authorization하기 때문에 세션 DB에 저장할 필요가 없다.

저장위치?

- JWT를 웹에서 저장하기 위해서는 브라우저 저장소에 저장하는 방식과 쿠키에 저장하는 방식을 사용할 수 있다. 로컬 스토리지와 세션 스토리지 같은 브라우저 저장소에 JWT를 저장한다면 스크립트 공격(XSS)에 취약해진다. 쿠키에 저장할 때 `http-only` 를 사용한다면 HTTPS로만 쿠키가 전달되기 때문에 보안을 강화할 수 있고, CSRF 문제에 대해서는 CSURF같은 라이브러리를 사용함으로 해결할 수 있다.

access token & refresh token?

- access token & refresh token 방식은 토큰들에 유효기간을 주어서 보안을 강화시킨 것이다. access token은 유효기간이 짧은 토큰이고, refresh token은 access token보다 유효기간이 긴 토큰이다.

  - 사용자가 로그인을 하면 서버로부터 access token, refresh token 2개의 토큰을 받는다. 이때 서버는 refresh token을 안전한 저장소에 저장한다.

  - 서버로부터 받은 access token의 유효 기간이 지나지 않은 경우 사용자가 어떤 요청을 보낼 때 access token을 함께 보내고 서버는 유효한 지 확인 후 응답을 보낸다.

  - 서버로부터 받은 access token의 유효 기간이 지난 경우 사용자는 refresh token과 함께 요청을 보내고, 저장소에 저장되어 있던 refresh token과 비교한 후에 유효하다면 새로운 access token과 응답을 함께 보낸다.



> 출처
>
> https://velog.io/@design0728/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A0%80%EC%9E%A5%EC%86%8C-LocalStorage-SessionStorage-Cookie
>
> https://velog.io/@gotaek/%EC%84%B8%EC%85%98Session%EA%B3%BC-JWT

------

### 1.스크립트 로딩 전략

페이지의 모든 HTML은 순서 그대로 불러온다. JavaScript 를 사용해서 페이지 내의요소( [Document Object Model](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents#the_document_object_model))를 조작하려할때, HTMl의 요소보다 JAVASCRIPT파일을 먼저 불러와버리면 코드가 올바르게 동작하지 않을 수 있다.

- **고전적방식**

  - 고전적인 방법은 body 태그 후에 script 요소를 배치하는것이다. 모든 html을 읽은 후 에 스크립트를 불러와 실행한다.하지만 이 방식은 html dom을 모두 불러오기 전에는 스크립트 로딩과 분석이 완전히 중단 된다는 것이다. 실제 파일 수 가 많은 대형 사이트의경우 성능 정하를 야기시 킬 수 있다.

- #### async 와 defer

- **async**

  - async 특성을 지정하면 스크립트를 가져오는 동안 페이지는 로딩을 중단하지 않는다. 그러나 **스크립트 다운로드가 끝나면 바로 실행된다**. **실행도중에는 페이지 렌더링이 중단된다**. 스크립트의 실행 순서를 보장할 방법이 없는 방식이다.
  - 다른 스크립트에 의존하지 않는 독립 스크립트에 사용해야한다.

![img](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/What_is_JavaScript/async-defer.jpg)

```
<script async src="js/vendor/jquery.js"></script>

<script async src="js/script2.js"></script>

<script async src="js/script3.js"></script>
```

위코드를 실행시 html의 다운로드 실행순서를 보장 할 수 없다.

- async는 다수의 백그라운드 스크립트를 최대한 빠르게 불러와야 할 때 사용하면 이점이 있다.

**defer**

- defer 특성을 지정한 **스크립트는 페이지 내에 배치한 순서대로 불러오게 된다**. 또한 페이지 콘텐츠를 모두 불러오기 전까지는 실행하지 않는다. 페이지 요소를 수정하거나,추가하는 등의 DOM작업을 기대하는 스크립트에 유용한다.

```
<script defer src="js/vendor/jquery.js"></script>

<script defer src="js/script2.js"></script>

<script defer src="js/script3.js"></script>
```

**위 코드의** **경우 실행** 순서를 보장 받을 수 있으며, DOM이 그러져민 스크립트는 실행된다.

**요약**

- `async`와 `defer` 모두, 브라우저가 페이지의 다른 내용(DOM 등등)을 불러오는 동안 스크립트를 별도 스레드에서 불러오게 만듭니다(동시에 다운로드는 가능). 덕분에 스크립트를 가져오는 동안 페이지 로딩이 중단되지 않습니다.

- `async` 특성을 지정한 스크립트는 다운로드가 끝나는 즉시 실행합니다. 실행은 현재 페이지 렌더링을 중단하며, 실행 순서는 보장되지 않습니다.

- `defer` 특성을 지정한 스크립트는 순서를 유지한 채로 가져오며 모든 콘텐츠를 다 불러온 이후에 실행합니다.

- 의존성 없는 스크립트를 불러온 즉시 실행하려면 `async`를 사용하세요.

- 다른 스크립트에 의존하거나 DOM 로딩이 필요한 스크립트에는 `defer`를 사용하고, 원하는 순서에 맞춰서 `<script>` 요소를 배치하세요.

---



### 2.값과 자료형

자바스크립트 (ES6 기준) 는 7개의 타입이 있다. 6개의 원시타입과 1개의 객체타입이 존재한다.

원시타입관 객체타입의 구분 이유

- 원시타입의 값, 즉 원시값은 변경불가능한 값이다(immutable value)이다. 이에 비해 객체(참조)타입의 값, 즉 객체 는 변경가능한(mutable value) 값이다. 

- 원시 값은 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 이에 비해 객체를 변수(확보된 메모리 공간)에 할당하면 변수에는 참조값이 저장된다.
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 **값에 의한 전달**이라한다. 이에 비해 객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 **참조에 의한 전달**이라 한다.



변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다.

!!할당연산자는 값이 저장된 메모리 공간의 주소를 할당한다.

변수: 하나의 값을 저장하기 위해 확보된 메모리 공간(메모리 주소)

값: 변수에 저장된 데이터로서 표현식이 평가되어 생선된 결과

`변경 불가능하다는 것은 변수가 아니라 값이다.` 

- 원시 값은 변경불가능하다.하지만 변수는 언제든 재할당을 통해 변경가능하다.

  - 재할당이란 새로운 메모리 공간을 확보 할당 후, 변수는 새로운 원시값을 가리킨다.

- <img src="https://velog.velcdn.com/images%2Fmr_chu%2Fpost%2F6eec5b62-8105-483e-bfff-088b9318c8dd%2F%EB%B3%80%EC%88%98%20%EC%9E%AC%ED%95%A0%EB%8B%B9.jpeg" alt="변수 값의 할당과 재할당"  />

- 값에 의한 전달

  - 값의 의한 할당이 일어나면, 평가된 값은 같지만 할당된 메모리공간은 별개이다.

  - <img src="https://velog.velcdn.com/images%2Fsozero%2Fpost%2F67c6f130-24c3-4c35-b819-28b17ce9ed99%2F11%E1%84%80%E1%85%A1%E1%86%B9%E1%84%8B%E1%85%A6%E1%84%8B%E1%85%B4%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%83%E1%85%A1%E1%86%AF.png" alt="img" style="zoom: 67%;" />

  - ```javascript
      let score = 80;
      // score의값 80이 할당
      let copy = score
      // -> true
      console.log(score === copy);
      score = 100;
      // -> false
      console.log(score === copy);
    ```

    

#### 타입

- 정수(number) - 숫자 , 정수와 실수 구분 없이 하나의 숫자타입만 존재한다.

  - int,long,float,double 등과 같이 다앙햔 숫자 타입이 없다. **모든 수를 실수로 처리한다.** (정수를 표현하는 데이터 타입은 존재하지 않는다.)

  - 모두 10진수로 처리된다.

  - 숫자를 처리하는 특별한 값도 존재한다

    - Infinity : 양의 무한대

    - -Infinity : 음의 무한대

    - NaN : 산술 연산 불가

    - 대소문자를 구변함으로 NaN으로 표기

    - BigInt

      - 길이에 상관없이 정수를 나타낼수 있음

      - ```javascript
        // 끝에 'n'이 붙으면 BigInt형 자료입니다.
        const bigInt = 1234567890123456789012345678901234567890n;
        ```

- 문자형 (string) - 문자열은 따옴표로 묶는다.

  - 따옴표는 세 종류가 있습니다.
    1. 큰따옴표: `"Hello"`
    2. 작은따옴표: `'Hello'`
    3. 역 따옴표(백틱, backtick): `Hello`
  - 원시 타입으로 변경 불가능한 값이다.

- 불린형(논리 타입) - 불린형(논리 타입)은 `true`와 `false` 두 가지 값밖에 없는 자료형입니다.

- undefined

  - 변수를 선언 후 값이 할당되지 않는다면, 자바스크립트 엔진이 기본적으로 값을 할당하는 값.
  - 값이 현재 할당되지 않는 상태이다.
  - 변수에 undefined을 사용하는것 보다 null을 사용하자.

- null - null타입의 값은 null이 유일하다.

  - 값이 없다는것을 의도적으로 명시
  - 존재하지 않음, 비어있음을 명시

- 심벌 타입

  - 변경 불가능한 원시타입이다.

  - 심벌 값은 다른 값과 중복되지 않는 유일무일한 값이다.

  - 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용된다.

  - ```javascript
    const objKey = Symbol("obj");
    const obj = {};
    obj.objKey = objKey;
    ```

#### 데이터 타입에 의한 값의 해석

자바스크립트 엔진은 데이터 타입. 즉 값의 종류에 따라 정해진 크기의 메모리공간을 확보한다. 즉 변수에 할당되는 값의 데이터 타입에 따라 확보되어야 할 메모리 공간의 크기가 결정된다.

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정
- 값을 참조할때 읽어 들어야 할 메모리 공간의 크기를 결정
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정
  - 심벌테이블: 컴파일러 또는 인터프리터는 심벌테이블 이라고 부르는 자료 구조를 통해 식별자를 키로 바인된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.

#### 동적 타이핑

자바스크립트 변수는 선인이 아닌 할당(깂)에 의해 타입이 결정된다. 그리고 재할당(값의 변화)에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.

<> 정적타입(명시적 타입선언): 변수를 선언할때 데이터 타입을 선언 ex) java String name;

- 변수는 꼭 필요한 경우 제한적으로 사용한다.
- 변수의 유효범위(스코프)는 최대한 좁게 만들어 사용한다.
- 전역변수는 최대한 사용하지 않는다.
- 변수보다는 상수를 사용한다 `CONST 사용!!`
- 변수의 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.

#### 암묵적 형 변환

자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다.

자바스크립트 엔진은 표현식을 평가할때 코드의 문맥을 고려해 암묵적으로 데이터 타입을 강제 변환한다.

```javascript
const string_1 = "1";
const string_2 = "2";
const number_1 = 1;
const number_2 = 2;
// -> 12
console.log(string_1 + number_1);
// -> 12
console.log(string_1 + string_2);
// 3
console.log(number_1 + number_2);
// 1true -> string 으로 변환?
console.log(string_1 + true);
// 1false
console.log(string_1 + false);
// string
console.log(typeof (string_1 + true));
// -> 2 true는 number 1로 변환
console.log(number_1 + true);
// -> 1 fals는 number 0으로 변환
console.log(number_1 + false);
// -> 1 null은 number 0으로 변환
console.log(number_1 + null);
// NaN undefined은 숫자로 타입 변환되지 않는다.
console.log(number_1 + undefined);
// true 동등비교연산이 일어날 경우에도 자동 형변환이 일어난다.
console.log(string_1 == number_1);
// false 일치비교연산시는 자동형변환이 일이나지 않음(타입 및 값을 비교).
console.log(string_1 === number_1);
// 일치비교 연산시 팁!! -> false
// NaN은 isNaN 또는 object.is로 비교
console.log(NaN === NaN);

function checkTypeOf() {
  console.log("null ", typeof null);
  // null은 object로 반환한다. js의 버그이다.
  // type of 는  원시타입5개(null 제외) + object + function 총 7개 형태로 반환한다.
  // 함수의 타입은 function이다.
  // 배열은 유사배열 객체로 object 타입이다. 배열 확인은 Array.isArray()함수를 통해 확인.
  // null 타입은 반환하지 않는다.
  const temp = null;
  const obj = {};
  // temp의 타입은 object다.
  console.log("temp의 타입은 ? ", typeof temp);
  // false
  console.log(typeof temp === null);
  // true
  console.log(typeof temp === typeof obj);
  // true
  console.log(temp === null);
}
```

- 암묵적 타입 변환이 일어나는 조건식일때의 값
  - Falsy값
    - flase
    - undefined
    - null
    - 0,-0
    - NaN
    - '' (빈문자열)

### 3.유용한 연산자

#### 단축평가

||(논리핪) or &&(논리곱) 연산자 표현식의 평가결과는 불리언 값이 아닐 수도 있다. 두 연산자는 언제나 2개의 피연산중 어느 한쪽으로 평가된다. 왼쪽연산자 부터 시작해 오른쪽으로 나아가며 피연산자를 계산한다.

- || 연산자
  - 각 피연산자를 불린형으로 변환하여 평가한다음, true이면 평가를 멈추고 변환전 해당값 반환한다.
  - 모든값이 false로 평가되는 경우 변환전 마지막값을 반환한다.
- && 연산자 
  - 각 피연산자를 불린형으로 변환하여 평가한다음, false이면 평가를 멈추고 변환전 해당값 반환한다.
  - 모든값이 true로 평가되는 경우 변환전 마지막값을 반환한다.

| true \|\| anything  |   true   |
| :-----------------: | :------: |
| false \|\| anything | anything |
|  true && anything   | anything |
|  false && anything  |  False   |



```javascript
// 단축평가를 사용한 기본값 설정
function shortEvaluation(v) {
  // falsey한 값일 경우 우항의 값으로 취환된다.
  v = v || "notValue"
  console.log(v);
  return v
}

// 매개변수의 기본값 설정시
// 인자값이 null(값이 전달되지 않았을때) or undefined 인경우만 동작한다.
function isDefaultParams(v = "notValue") {
  console.log(v);
  return v
}

// -> notValue
shortEvaluation(NaN)

// -> undefined (기본값으로 취환되지 않음.)
isDefaultParams(NaN)

// arguments의 null은 notValu로 취환 -> notValue
isDefaultParams()

```



Nullish 병합 연산자 ??

- nullish의 경우 || 연산자와 비슷해보이지만 || 연산자의 경우 앞의 값이 `falsey`값인 경우 뒤의값을 취하지만 `?? 병합연사자의 경우 앞의 값이 null || undefined인 경우에만` 뒤의 값을 취한다. 

  ```javascript
  let height = 0;
  // 좌항의 값을 블리언으로 변환후 false이면 우항의값을 반환한다.
  alert(height || 100); // 100
  // 좌항의 값이 null 또는 undefined 이면 우항의값을 반환한다. 
  alert(height ?? 100); // 0
  ```

- 연산자 우선순위가 5로 낮기 때문에 괄호를 사용하자.

- 안정성 관련 이슈 때문에 `??`는 `&&`나 `||`와 함께 사용하지 못한다.

/ > `인용구`

#### 옵셔널 체이닝

?.연산자는 좌항의 피연산자가 null 또는 undefined 인경우 평가를 멈추고 undefined을 반환하고, 그렇지 않으면 우항의 프로퍼티 값을 참고한다.

- 이는 객체가 null 또는 undefined 아닌지 확인하고 객체의 프로퍼티를 참고할때 유용한다.

- ```javascript
  function checkFunction(obj) {
    console.log("user:",obj?.user); 
    console.log(obj?.printUser?.());
  }
  
  const info1 = {
    user:"kwon",
    printUser(){return this.user}
  }
  const info2 = {}
  // 실제 프로퍼티가 존재하기에 -> kwon이 찍힌다.
  checkFunction(info1)
  // 존재하지 않는 프로퍼티에 접근하였기에 undefined을 반환한다.
  // 옵셔널 체이닝을 사용하지 않았을경우 참조에러로 app crashed가된다.
  checkFunction(info2)
  
  ```

- 옵셔널 체이닝을 남발할 경우 초기에 에러를 발견하지 못하거나,디버깅이 어려워 질 수 있다.(필수값에는 사용하지 말자.)

- 참조하는 변수는 꼭 선언 되어 있어야한다!!!

  

***



### 4.객체

객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다. 객체는 원시타입 (immutable value)과는 다르게 다양한 타입의 값으로 구성된 복합적인 자료구조이다. 원시타입의 값은 변경 불가능하지만, **객체 타입의 값은 변경가능하다**. 자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다. 함수 또한 일급 객체 이므로 프로퍼티로 사용 할 수 있다. 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다.

- 객체 리터럴

  - 리터럴: 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법이다.


  ```javascript
  const info1 = {
    user:"kwon",
    printUser(){return this.user}
  }
  // 빈객채를 생성
  const info2 = {}
  ```

- **객체를 대괄호 연산자로 접근할 경우 반드시 따옴포로 감싼 문자열로 접근해야한다. `이는 자바스크립트 엔진이 식별자로 해석하기 때문이다.`**

  - 식별자는 값이 될수 있다.

- ```javascript
  // kwon
  console.log(info1["user"]);
  // error -> user is not defined
  const key1 = "user"
  // kwon
  console.log(info1[key1]);
  ```

- 객체의 접근경우 변수에 할당된 참조값에 의해 메모리에 접근하면, 참조값(참조 주소)은 객체가 저장된 메모리 공간의 주소이다.

  - 메모리에 저장되어 있는 참조값을 통해 실제 객체(데이터)에 접근한다.

  - 원시값의 변경불가능한 값으로, 재할당을 통해 값을 변경한다. `반면 객체는 변경 가능한 값이므로 메모리에 저장된 객체를 직접 수정할 수 있다.`

    - 객체에 할당한 변수의 참조값은 변하지 않는다.(하지만 참조값의 실제 데이터는 수정가능하다.)
    - 이는 객체를 복사해서 생성하는 비용을 절약하여 성능적 향상을 가져가기 위함이다.

  - ```javascript
    function checkObj() {
     const a = {
       name:"kown"
     }
     const b = a
     // true: 둘의 저장된 메모리는 다르지만 동일한 참조값을 바라본다.
     // 값에 의한전달.
     console.log(a===b);
     b.update = true
     // b의값이 변하면 a의값도 변한다.
     console.log(a);
     console.log(b);
      // a객체와 b객체는 같은 메모리 주소를 참고한다.
      // a -> { name: 'kown', update: true }
      // b -> { name: 'kown', update: true }
     console.log(a===b);
    }
    ```

  - 얕은 복사 vs 깊은복사

    - 객체를 프로퍼티 값으로 갖는 객체의 경우 얕은 복사는 한 단계까지만 복사하는 것을 말하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.

    - 얕은 복사로 만들어진 객체는 별개의 객체이다. 하지만 중첩되어 있는 객체의 경우 객체의 참조값을 복사한다.

    - 반면 깉은 복사의 경우 객체에 중첩되어 있는 객체까지 모수 복사하여 완전한 복사본을 만든다.

      - 깊은복사 방법
        - 재귀를 통한 방법
        - JSON.parse(JSON.stringify(obj));
          - JSON 문자열로 변환후 객체화 (느리다...)

        - [lodash](https://lodash.com/)의 메서드인 [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)을 사용
        - 참고 - https://ko.javascript.info/object-copy

    - ```javascript
      // 얕은복사
      const obj1 = {name:"kwon",isUpdate:false,keyList:["kwon",false,5],innerObj:{a:"aaa",b:"bbb"}}
      // 얕은복사 둘의 결과는 같다.
      const obj2 = Object.assign({},obj1)
      // const obj2 = {...obj1}
      // -> false 
      console.log(obj1 === obj2);
      // -> true 실제 중첩되어 있는 객체의경우에도 같은 참조값을 봐라본다.
      console.log(obj1.keyList === obj2.keyList);
      
      // 중복 객체의 경우 같은 참조값 가짐.
      obj1 :  {
        name: 'kwon',
        isUpdate: false,
        keyList: [ 'kwon', false, 5 ],
        innerObj: { a: 'aaa', b: 'bbb' }
      }
      
      obj2 :  {
        name: 'kwon',
        isUpdate: false,
        keyList: [ 'kwon', false, 5 ],
        innerObj: { a: 'aaa', b: 'bbb' }
      }
      
      // 깊은복사
      // 재귀를 통한 복사.
      function copy (_obj){
        const result = Array.isArray(_obj) ? [] : {}
      
        for (const key in _obj) {
          if(typeof _obj[key] === "object"){
            result[key] = copy(_obj[key])
          }else{
            result[key] = _obj[key];
          }
        }
        return result;
      }
      
      // lodash 사용
      const lodash = require("lodash");
      const obj2 = lodash.cloneDeep(obj1);
      const obj2 = copy(obj1);
      // -> false
      console.log(obj1.keyList === obj2.keyList);
      
      // 전개연산자를 통해 새로운 객체를 만들고 필요한 부분만 다시설정한다.
      const obj1 ={name:"k",num:5,list:[1,2,3]};
      const obj2 = {...obj1,num:10,list:[...obj1.list,10,20]};
      
      // ->{ name: 'k', num: 5, list: [ 1, 2, 3 ] } { name: 'k', num: 10, list: [ 1, 2, 3, 10, 20 ] }
      console.log(obj1,obj2);
      // false
      console.log(obj1 === obj2);
      
      
      
      ```


***

  

### 5.함수

함수는 객체타입으로 선언된 함수 이름은 함수 참조값 or 참조주소(힙 영역)에 의해 메모리에 접근한다.

- 객체의 접근경우 변수에 할당된 참조값에 의해 메모리에 접근하면, 참조값(참조 주소)은 객체가 저장된 메모리 공간의 주소이다(실제 데이터 영역).

- 함수는 함수명으로 호출되는 것이 아니라, 함수 객체를 가르키는 식볋자로 호출한다.

  - -자바스크립트는 함수명을 암묵적으로 할당함.

- ```javascript
  // 함수이름(매개변수,인자) -> parameter
  // 각 매개변수에는 함수를 호출할때 지정한 인수가 순서대로 할당된다.
  // 매개변수의 스코프는 함수내부.
  // arguments를 통해1값의 객체를 확인 할 수 있다.
  function  callFunction(a,b) {
    return a+b
  }
  // 인수(argument) -> 인수는 값으로 평가될 수 있는 표현식이여야 한다.
  callFunction(1,2)
  
  function fun_1(num) {
    return num; 
  }
  
  // 함수는 참조타입으로 변수에 함수식별자의 값(참조 주소)을 할당 한다.
  // 실행값 x -> 단지 변수(식별자)에 할당된 값(참조 주소)을 할당
  const getNum = fun_1;
  // -> true
  console.log(getNum === fun_1);
  
  
  ```

-  자바스크립트의 모든 선언문은 런타임 이전에 모두 생성된다.

  - 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체를 생성한다.

  ```javascript
  // -> error
  console.log(add(1,2));
  // 호이스팅
  // 실제호이스팅은 선언만 코드의 최상단으로 끌어올려줘 실행된다.
  console.log(isHosting());
  
  // 함수 선언문
  function isHosting() {
    return console.log("isHosting"); 
  }
  // 함수 표현식
  const add = function adds(x,y) {
    return console.log(x,y);
  }
  ```

- 함수는 가급적 한가지 일을 수행해야 한다.

- 매개변수의 갯수는 제한이 없지만, 최대한 적게 넘기는게 좋다.

- 키워드 인자값이 없고, 인수의 순서되로 할당되기에,객체를 만들어 키값에 접근하는 방식도 좋다.

- return문 -> 기본적으로 undefined을 반환

  - `return문을 만나면 함수는 종료된다.`


#### 화살표 함수

화살표 함수는 기존의 함수 선언문 또는 함수 표현식을 완전히 대체하기 위해 디자인된것은 아니다. 화살표 함수는 기존의 함수보다 표현만 간략한 것이 아니라 내부 동작 또한 간략화되어 있다.

- 생성자 함수로 사용할 수 없다.
- 기존 함수와 this 바인딩 방식이 다르다.
  - 함수 선언시 선언된 상위 렉시컬환경의 this를 바인딩한다.

- Prototype 프로퍼티가 없다.
- arguments 객체를 생성하지 않는다.

#### 일급객체(일급함수)

함수를 값처럼 자유롭게 사용할 수 있다.

- 일급객체의 조건
  - 무명의 리터럴로 생성할 수 있다.즉, 런타임에 생성이 가능하다.
  - 변수나 자료구조에(객체,배열)에 저장할 수 있다.
  - 함수의 매개변수에 전달할 수 있다.
  - 함수의 반환값으로 사용할 수 있다.

- 일반 객체처럼 모든 연산이 가능한것
  - 함수를 매개변수로 전달할 수 있음. -> 함수의 참조값 전달
  - 함수를 반환값 으로 사용할 수 있음.
  - 함수를 변수에 할당 할 수 있음(함수 표현식).
  - 동일비교 대상
  - 객체의 프로퍼티값이 될 수도 있으며, 배열의 요소가 될 수 있다.

함수가 일급 객체라는 것은 함수를 객체와 동일하게 사용할 수 있다는 의미다.

그러나 일반객체는 호출할 수 없지만, 함수 객체는 호출할 수 있다.그리고 함수 객체는 일반 객체에는 없는 함수 고유의 프로퍼티를 소유한다.

```javascript
// ->undefined __proto__는 함수의 프로퍼티가 아니다.
// 배열
//console.log(Object.getOwnPropertyDescriptor(firstClassObject, '__proto__'));
// 함수의 프로퍼티
console.log(Object.getOwnPropertyDescriptors(firstClassObject));
```

![image-20220610222217657](/Users/khg/Library/Application Support/typora-user-images/image-20220610222217657.png)

```javascript
function confirmFuncionProto(a) {
  // arguments는 유사배열 객체이다.
  // 함수 호출시 전달된 인수이다.
  // 매개변수와 일치하지 않는다.
  // -> [Arguments] { '0': 1, '1': 2, '2': 3, '3': 4, '4': 5 }
  console.log(arguments);
  // 만약 초과된 인수는 undefined으로 초기화된다.
  
  // rest나 전개연산자로 배열화가능.
  console.log([...arguments]);
}

```

- 유사배열 객체와 이터러블

  - es6에서 도입된 이터레이션 프로토콜을 준수하면, 순회 가능한 자료구조인 이터러블이 된다.
  - 유사배열 객체는 배열이 아니다, 배열 메서드를 사용할 경우 에러가 발생한다.
  - call 또는 apply을 적용하거나 loop 메서드를 사용

- 함수객체의 name

  - 기본적으로 함수의 이름을 나타낸디.

  - es6 에서는 익명함수 객체를 가리키는 식별자를 값으로 갖는다.

  - 함수 이름과 함수 객체를 가르키는 식별자는 의미가 다르다. 함수를 호출할 때는 함수 이름이 아닌 함수 객체를 가르키는 식별자로 호출한다.

  - ```javascript
    const confirmF = confirmFuncionProto;
    const nameF = () => {};
    // -> confirmFuncionProto
    console.log(confirmF.name);
    // -> nameF
    console.log(nameF.name);
    ```

#### 고차함수

- 인자로 함수를 받음(콜백함수)
  - 함수를 인자로 받아 함수를 합성하여 사용.
  - 함수의 공통로직은 두고 액션 함수에 따라 목적에 맞게 사용 할 수 있다.
  - 콜백함수는 함수형 프로그램의 기본패러다임 일뿐 아니라, 비동기 처리(이벤트처리,Ajax통신, 타이머 함수)의 중요패턴 중 하나이다.
- 함수를 반환하는 함수

#### 순수함수

함수형 프로그래밍에서 어떤 외부 상태에 의존하지 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수라한다.

- 외부 상태에 의존하지 않고, 오직 매개변수를 의존해 값을 생성한다.
- 최소 하나의 인수를 전달받아 동일한 값을 반환한다.

#### 불변성 

함수내부에서 외부로부터 주어진 인자의 값을 변경하는것은 추천하지 않는다.

- 원식 타입의 경우(변경불가능) 재할당을 통해 값을 변경하기에 상관없음.
- 반면 객체 타입의 경우 참조에 의한 전달이기에 언제든 객체데이터의 변경이 가능하다.
- 객체의 경우 참조에 의한 복사임으로 외부로부터 주어진 객체를 함부로 변경하지말자.
  - 객체변경에 따른 코드추적이 어려워 질수 있다.

- 상태 변경이 필요한 경우에는, 새로운 객체를 만들어서 반환해야함.

- ```javascript
  function chageObjNum(obj) {
    // 얕은복사로 새로운 객체를 만들고 필요값을 변경하자.
    return {...obj,num:2} 
  }
  const obj1 ={name:"k",num:5};
  // -> name:"k",num:2
  const obj2 = chageObjNum(obj1);
  ```

#### 중첩함수

함수 내부에 정의된 함수. 중첩 외부 함수 스코프 내에서만 호출 할 수 있다. 일반적으로 중첩함수는 외부함수를 돕는 헬퍼 함수의 역할을 한다.

```javascript
function outerFuncion(arr){
  // 함수안의 헬퍼함수를 만들어 함수 스코프 내부에서 사용할 수 있다.
  function multiply(a){
    return a * 2
  }
  return arr.map((v)=>multiply(v))
}
// -> [ 2, 4, 6, 8, 10 ]
console.log(outerFuncion([1,2,3,4,5])); 
```

***



### 6.스코프(Scope)

스코프는 변수,함수,클래스이름(식별자)의 유효한 범위이다(실행 컨택스트). 이는 선언된 위치에 따라 유효범위가 결정된다. 스코프의 범위는 블럭 안에서만 유효하다. 스코프는 식별자가 유효한 범위를 말한다.

- 스크프의 종류
- 전역: 코드의 가장 바깥 영역 (전역변수)
- 지역: 함수 몸체 내부 (지역변수)

> 현재 실행 컨텍스트입니다. [값](https://developer.mozilla.org/en-US/docs/Glossary/Value) 과 **표현식** 이 "표시"되거나 참조될 수 있는 컨텍스트입니다 . 변수 또는 기타 표현식이 "현재 범위에" 있지 않으면 사용할 수 없습니다.범위는 계층 구조로 계층화될 수도 있으므로 하위 범위가 상위 범위에 액세스할 수 있지만 그 반대는 불가능합니다.
>
> **[함수](https://developer.mozilla.org/en-US/docs/Glossary/Function)** 는 [JavaScript](https://developer.mozilla.org/en-US/docs/Glossary/JavaScript) 에서 **클로저** 역할을 하므로 범위를 생성하므로 (예를 들어) 함수 내에서만 독점적으로 정의된 변수는 함수 외부 또는 다른 함수 내에서 액세스할 수 없습니다.
>
> ---https://developer.mozilla.org/en-US/docs/Glossary/Scope

```javascript
function basisScope() {
  // 지역변수는 자신의 스크포와 하위 스코프에서 사용 가능하다.
  const outer = 'test';
  {
    const inner = 'inner';
    // 상위 스코프 변수에 접근가능
    console.log(outer);
  }
  // 같은 스크프에 있는 변수 
  console.log(outer);
  // 하위 스코프 변수에 접근 불가능
  //-> 접근 불가
  // console.log(inner);
}
```

코드 블록이 정의되는곳

If, for,{},function(){},switch, try...*catch*문

- 이름 충돌방지
  - 유효범위를 가짐으로써 식별자의 충돌을 막을 수 있다.
  - 스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용 할 수 있다.

- 메모리 절약

#### 렉시컬 환경

코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 렉시컬 환경이라고 한다.즉 코드의 문맥은 렉시컬 환경으로 이뤄진다.이를 구현한것이 실행 컨텍스트이며, 모든 코드는 실행 컨택스트에서 평가되고 실행된다.

- 렉시컬 스코프 또는 정적 스코프 : 함수를 어디서 정의했는지에 따라 함수의 상위스코프를 결정한다.이는 함수정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다.
- 함수가 정의된 스코프에서 상위 스코프를 결정.

```javascript
// 렉시컬 스코프: 함수의 선언된 위치에 따라 상위 스코프를 결정
function checkScope() {
  let x = 1;

  function foo(params) {
    let x = 10;
    //-> 10
    console.log(`foo의 x는${x}`);
    // 함수의 호출 스코프와 상관없이 함수가 선언된 스코프에서 동작
    // 스코프체인시 함수의 상위 스코프 x의값(1)를 참조한다.
    bar();
  }

  function bar(params) {
    // -> 1이 출력
    console.log(`bar의 x는${x}`);
  }
  foo();
}
```

- 각각의 블록은 렉시컬 환경을 가지고 있다.
  - 환경레코드
  - 외부 환경 참조(이는 내부스코프에서 스코프 체인을 통해 외부 레시컬 환경에 접근할 수 있기 때문이다.
  - 스코프 체인: 스코프가 계층적으로 연결된 형태
  - 자바스크립트 엔진은 스코프체인을 통해 변수를 참조하는 스코프에서 시작하여 상위로 이동 (단방향 연결)하며 선언된 변수를 검색 한다. 
  - ![스코프 체인과 클로저](https://images.velog.io/images/rlatmdgns94/post/d1b27a4f-c73b-4515-8264-e2605f5636b2/_.png)

#### 실행컨텍스트

실행컨텍스트는 자바스크립트엔진이 코드를 해석하고 실행의 복잡성을 관리하는 방법이다. 실행컨텍스트는 코드의 함수,변수 및 객체에 엑세스할 수 있는 코드 섹션을 결정한다.

자바스크립트는 실행 컨텍스트가 활성화되는 시점에 다음과 같은 현상이 발생한다.

- 호이스팅이 발생한다(선언된 변수를 위로 끌어올린다)
- 변수 객체(Variable Object)를 생성한다.
- 스코프 체인을 통해 외부 환경 정보를 구성한다
- this에 바인딩할 객체를 결정한다.

실행컨테스트의 두 단계

- 코드 생성
- 실행 단계

##### 전역 실행 컨테스트

- 코드를 한줄도 작성하지 않더라고 자바스크립트 엔진이 시작될 때 생성되는 첫번째 실행컨텍스트이다.

##### 생성단계

- 생성 단계에서는 자바스크립트 엔진은 컴파일 단계에 있으며 변수 및 함수 선언만 검색하고 코드를 실행시키지는 않는다.
- 전역객체 생성
  - 브라우저는 window로 전역객체를 생성
  - 노드의 경우 global로 생성
- this객체를 생성하고 window에 바인딩한다.
- 변수 및 함수를 메모리에 생성한다.
  - var의 경우 undefined로 변수를 초기화하고 -> 선언전 접근이 가능하다. 
  - let과 const는 초기화 되지 않은채 생성된다. -> 선언전 접근을 하면 reference error를 발생시킨다.
  - 함수선언을 메모리에 생성한다.   

- 실행단계: 실제 코드를 읽기시작.
  - 함수 호출이 실행된다.
  - 값은 변수에 할당된다.
- 함수 실행컨테스트
  - 함수 실행컨테스트는 모든 함수 호출에 대해 생성되므로 각 함수에는 고유한 실핸 컨텍스트가 존재한다.함수가 선언될 때 생성되지 않고 호출될때 생성된다.
  - 전역 실행 컨텍스트가 먼저 생성되고 실행 스택으로 푸시됩니다.
  - JavaScript 엔진은 전역 실행 컨텍스트에서 코드 구문 분석을 시작합니다.
  - 모든 함수 호출에 대해 새로운 함수 실행 컨텍스트가 생성되고 실행 스택에 푸시됩니다.
  - 함수 실행이 완료되면 해당 컨텍스트가 스택에서 팝된다.



![img](https://miro.medium.com/max/1400/1*ueB_efK6SLLsF0JNjmd4hA.png)



> 참조
>
> https://medium.com/@ayoub-mabrouk/understanding-execution-context-and-execution-stack-and-hoisting-in-javascript-dfc26eadf529
>
> https://junilhwang.github.io/TIL/Javascript/Domain/Execution-Context/#summary

#### 호이스팅

자바스크립트 엔진이 코드를 실행하기 전 변수,함수,클래스의 선언문을 코드 최상단으로 끌어올리는것

- 런타임 이전에 변수는 할당이된다.

변수의 선언과 초기화를 분리한 후, 선언만 코드의 최상단으로 옮김

- ```javascript
  function checkHoisting(params) {
    // 함수의경우 호이스팅으로 실행된다.
    hoisting();
    // ReferenceError: Cannot access 'checkVar' before initialization
    // console.log(checkVar);
    // ReferenceError: Cannot access 'hoistingFunction' before initialization
    // hoistingFunction();
  
    // let,const,클래스
    // 선언만 호이스팅이되고, 초기화는 되지 않는다.
    // 초기화전 변수에 접근하면 컴파일 에러가 발생한다.
  
    // 만약 var를 사용했다면 undefined이 찍힌다.
    function hoisting() {
      const test = 'test';
    }
  
    const checkVar = 'checkVar';
    const hoistingFubction = hoisting;
  }
  ```

#### GC

메모리 생명주기

1.필요한 메모리 할당

2.할당된 메모리 사용(읽기,쓰기)

3.더 이상 필요하지 않을 때 할당된 메모리 해제

> JavaScript는 객체가 생성될 때 자동으로 메모리를 할당하고 더 이상 사용되지 않을 때 해제합니다( *가비지 수집* ). 이러한 자동성은 잠재적인 혼란의 원인입니다. 개발자에게 메모리 관리에 대해 걱정할 필요가 없다는 잘못된 인상을 줄 수 있습니다.
>
> ### [값 사용](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#using_values)
>
> 값을 사용한다는 것은 기본적으로 할당된 메모리에서 읽고 쓰는 것을 의미합니다. 이는 변수 또는 객체 속성의 값을 읽거나 쓰거나 함수에 인수를 전달하여 수행할 수 있습니다.
>
> ### [메모리가 더 이상 필요하지 않을 때 해제](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#release_when_the_memory_is_not_needed_anymore)
>
> 대부분의 메모리 관리 문제는 이 단계에서 발생합니다. 이 단계에서 가장 어려운 부분은 할당된 메모리가 더 이상 필요하지 않은 시점을 결정하는 것입니다.
>
> 저수준 언어는 개발자가 프로그램에서 할당된 메모리가 더 이상 필요하지 않은 지점을 수동으로 결정하고 해제해야 합니다.
>
> JavaScript와 같은 일부 고급 언어는 [가비지 수집](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)) (GC)으로 알려진 자동 메모리 관리 형식을 활용합니다. 가비지 수집기의 목적은 메모리 할당을 모니터링하고 할당된 메모리 블록이 더 이상 필요하지 않은 때를 결정하고 이를 회수하는 것입니다. 이 자동 프로세스는 특정 메모리 조각이 여전히 필요한지 여부를 결정하는 일반적인 문제를 결정할 수 없기 때문에 근사치 [입니다](https://en.wikipedia.org/wiki/Decidability_(logic)).
>
> 참조
>
> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management
>
> 



- 전역변수와 지역변수
  - 전역변수의 생명주기는 애플리케이션의 생명주기와 같다
  - `함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료되면 소멸한다.` 
  - 변수는 하나의 값을 저장하기 위해 확보된 메모리 공간 자체이다. 변수의 생명주기는 메모리공간 확보 -> 해제 -> 메모리 풀에 반환 까지이다.
- 전역변수의 문제점
  - 암묵적 결합:코드를 어디에서든 참조하고 할당할 수 있다는것을 의미한다.
    - 변수의 유효범위가 클수록 코드의 가독성은 나뻐지며,의도치 않게 상태가 변경될 수 있다.
  - 긴 생명주기
    - 메모리 리소스도 오랜 기간 소비한다.
    - 만약 var키워드를 사용한다면 의도치 않는 재할당이 일어날수 있다.
    - 파일이 분리되어 있다해도. 변수가 공유된다는 것이다. 이는 다른 파일내에서 동일한 이름으로 망명된 전역변수나 전역 함수가 같은 스코프 내에 존재할 경우 예기치 못한 결과를 가져올 수 있다.



#### var키워드의 문제점	

- 중복선언이 가능하다

- 오로지 **함수의 코드 블록**만을 지역스크프로 인정한다.따라서 함수 외부에서 var키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.
  - var키워드로 선언한 전역 변수의 생명주기는 전역 객체의 생명주기와 일치하다.
  
- 변수 호이스팅에 의해 초기 undefined값이 할당된다.

- ```javascript
  function checkVar() {
    // 실제 초기화전 undefined이 할당된다.
    // -> undefined
    console.log(i);
    var i = 't';
    // -> t
    console.log(i);
    for (var i = 0; i < 2; i++) {
      // 1,2
      console.log(i);
    }
    
    // 현재 함수코드 블록에서 전체에서 공유되어 사용된다.
    console.log(`for문 바깥스코프의 i ${i}`);
  
    var i = '이상해';
    console.log(`var는 재선언 재할당도 가능하다. ${i}`);
    {
      var t = 't';
    }
    // 하위 스코프에 선언된 변수도 사용가능하다....
    // -> t
    console.log(t);
  }
  // !!error -> 오로지 함수의 코드 블록만을 지역스크프로 인정한다
  console.log(t);
  
  ```

- let 버전

- ```javascript
  // 함수 블록내 i변수와 전역스코프에 선언된 i변수는 다른변수이다.
  let i="globalT"
  function checkLet() {
    // !!error
    // Cannot access 'i' before initialization
    // console.log(i);
    let i = 't';
    // -> t
    console.log(i);
    // for문의 블록 레벨 스코프
    for (let i = 0; i < 2; i++) {
      // 1,2
      console.log(i);
    }
    // -> t
    console.log(`for문 바깥스코프의 i ${i}`);
  
    {
      let t = 't';
    }
    // !!error
    // t is not defined
    // 현재 렉시컬환경에 t라는 변수는 존재하지 않는다.
    console.log(t);
  }
  ```

  

#### let과 const

- **모든 코드블록**을 지역스코프로 인정한다.(일반적인 프로그래밍의 코드블록)

- 선언 단계와 초기화 단계가 분리되어 진행된다.

  - 런타임 이전에 자바스크립트 엔젠에 의해 암묵적으로 선언단계가 먼저 실행되고, 초기화 단계는 변수 선언문에 도달했을때 실행된다.

  - 호이스팅이 일어나지 않는거 같지만 실제로는 일어나며 선언단계 <-> 초기화 단계 사이 일시적 `사각지대영역`이 있다.

  - ```javascript
    function checkLetHoisting() {
      let isHoisting = '?';
    
      function check() {
        // Cannot access 'isHoisting' before initialization
        // 이는 함수 스코프내에서 호이스팅이 일어나 렉시컬체인 상위의 let으로 선언된 isHoisting 변수를 참조하지 않는다.
        console.log(isHoisting);
        const isHoisting = true;
      }
      check();
    }
    ```

  - 키워드로 선언한 변수는 전역객체(브라우저 에서는 window)의 프로퍼티가 아니다.

  - ```javascript
    var tt = 'tttttt';
    let cc = 'cccccc';
    // -> tttttt
    console.log(window.tt);
    // -> undefined
    console.log(window.cc);
    ```

  - let은 재선언이 불가하면 재할당은 가능하다.

  - const은 재선언 재할당 둘다 불가능하다.

    - const는 선언과 함깨 값을 할당해주어야 한다.
    - 상수처럼 사용가능하다.
      - 원시값을 할당할 경우 -> 원시 값은 변경 불가능한 값이므로
    - 객체를 할당할 경우 값을 변경 할 수 있다.
      - 실제 참조주소는 변경되지 않지만, 참조된 객체의 값은 변경가능하다.

+++

### 7.프로토타입(prototype)

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties

<u>**자바스크립트는 명령형,함수형,프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다.**</u>

**<u>자바스크립트는 객체기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 원식타입을 제외한 모든값들은 객체로 구성되어 있다.</u>**



자바스크립트의 모든 객체는 객체간 상속을 위해 object라는 내부의 prototype 가지고 있다.

- 자바스크립트의 내장된 기본 상태 및 함수이다.
- 직접 접근은 불가하지만, 내부슬롯의 경우 `__proto__` 접근자 프로퍼티를 통해 간접적으로 접근할 수 있다.

자바스크립트에서 객체간 상속의 연결고리는 프로토타입 체인으로 연결되어 있다

- 배열 -> array -> object



자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 속성을 기본값으로 자동정의한다.

#### 데이터 프로퍼티: 키와값으로 구성된 일반적인 프로퍼티.

- value: 객체속성의 값
- writable: 값을 변경할수 있을지의 유무(값의 갱신 가능 여부)
- enumerable: 속성을 열거가능한지
  - -false 인경우 in, Object 문의 열거함수로 열거 할 수없다.

- configurable: 속성이 삭제될수 있는지유무(재정의 가능 여부)

```javascript
const obj1 = {
  name: 'kwon',
  age: 31,
  desc() {
    return `age:${this.age},name:${this.name}`;
  },
};
// 객체의 권한을 수정해서 객체를 관리 할 수 있다.
Object.defineProperties(obj1, {
  name: {
    writable: false,
  },
  age: {
    value: 29,
    enumerable: false,
  },    
}); 
/**
{
  name: {
    value: 'kwon',
    writable: false,
    enumerable: true,
    configurable: true
  },
  age: { value: 29, writable: true, enumerable: false, configurable: true },
  desc: {
    value: [Function: desc],
    writable: true,
    enumerable: true,
    configurable: true
  }
*/
console.log(Object.getOwnPropertyDescriptors(obj1));


```

#### 접근자 프로퍼티

접근자 프로퍼티는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할때 사용하는 접근자 함수로 구성된다.

- ```javascript
  // 접근자 프로퍼티
  function accesoorProtp() {
    const user = {
      name: 'kwon',
      age: 31,
      get ageInfo() {
        return `${this.age}`;
      },
      set ageInfo(age) {
        this.age = age;
      },
    };
  
    // setter 호출
    user.ageInfo = 33;
    // getter 호출
    console.log(user.ageInfo);
  }
  ```

#### 프로퍼타입

프로퍼타입은 어떤 객체의 상위 객체의 역할을 하는 객체다. 프로퍼타입은 하위 객체에게 자신의 프로퍼티와 메서드를 상속한다. 하위 객체는 상위 프로퍼타입의 프로퍼티 또는 메서드를 사용 할 수 있다. 프로퍼타입 체인은 단방향 링크드 리스트 형태로 구성되어 있다. 객체나 메서드에 접근하려 할때 해당 객체의 프로퍼티 또는 메서드가 없다면, 프로퍼타입 체인을 따라 상위 프로퍼타입을 검색한다.

프로토타입 확인해보기

- ```javascript
  function checkProtoLevel(params) {
    function Info(name, age) {
      this.name = name;
      this.age = age;
      // 인스턴스 레벨의 함수
      // 각각의 객체마다 함수를 생성해서 가지고 았다.
      // 메모리상 비효율적.
      // this.printinfo = function () {
      //   return `name:${this.name}/age:${this.age}`;
      // };
    }
    // 프로토타입의 함수를 생성하면, 프로타타입레벨의 함수를 가질수 있다.
    Info.prototype.printUser = function () {
      return `name:${this.name}/age:${this.age}`;
    };
    const kwon = new Info('kwon', 31);
    const kim = new Info('kim', 27);
    console.log(kwon);
  }
  ```
  
  
  
- <img src="/Users/khg/Library/Application Support/typora-user-images/image-20220607230608685.png" alt="image-20220607230608685"  />

  #### 객체변경방지

  - ```javascript
    // 오브제트 프리징 -> 값의 읽기만 가능 나머지는 모두불가.
    // 객체를 동결시킨다.
    function immutabilityObj() {
      // 오브젝트 동결시키기
      const obj = {
        name: 'kwon',
        age: 31,
        inner: {
          a: 'a',
          b: 'b',
        },
      };
      // Prevents the modification of existing property attributes and values, and prevents the addition of new properties.
      // 기존 프로퍼티의 속성(키)과 값을 수정(삭제,쓰기,재정의)을 방지하고, 새로운 속성을 추가하는것을 방지한다.
    
      Object.freeze(obj);
      // age: { value: 31, writable: false, enumerable: true, configurable: false }
      // console.log(Object.getOwnPropertyDescriptors(obj));
      // 무시!!!!
      delete obj.name;
      obj.name = 'hi!';
      obj.plus = '+';
      // freeze도 얕은복사이다. 내부객체는 변경가능하다.
      // freeze시 내부 객체의 경우 같은 참조값을 보고있다. 참조 객체의 값을 수정하면 같이 변경된다.
      obj.inner.a = 'AA';
      // -> { name: 'kwon', age: 31, inner: { a: 'AA', b: 'b' } }
      console.log(obj.iss);
      console.log(obj);
    }
    ```

  - ```javascript
    // 오브제트 seal -> 기본 오브젝트의 형태를 유지하지만, 값의 수정은 가능하다.
    function sealObj() {
      const obj = {
        name: 'kwon',
        age: 31,
        inner: {
          a: 'a',
          b: 'b',
        },
      };
      //Prevents the modification of attributes of existing properties, and prevents the addition 	of new properties.
      // 속성은 변경불가 !! 값의 수정은 가능하다.
      Object.seal(obj);
      obj.name = 'HI!';
      delete obj.name;
      // -> { name: 'HI!', age: 31, inner: { a: 'a', b: 'b' } }
      console.log(obj);
      // seal되었는지 확인하다.
      // console.log(Object.isSealed(obj));
    }
    ```

  - 중첩객체(얕은방지)로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지 못한다. 재귀적으로 호출하여 freeze하자. 



#### 생성자 함수

객체 리털리에 의한 객체생성 방식은 단 하나의 객체만 생성한다. 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야하기에 비효울적이다.

생성자함수 : 객체(인스턴스)를 생성하는 함수.

일반함수와 같이 정의하고, new 연산자와 함께 생성자 함수를 호출한다.

- 인스턴스 생성과 this바인딩: 암묵적으로 빈 객체를 생성한다. -> 인스턴스는 this에 바인딩된다.
- 다음 과정은 함수실행 이전 런타임에 실행된다.

인스턴스 초기화 

- this에 바인딩되어 있는 인스턴스에 프로퍼티나 메서드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 할당하여 초기화하거나 고정값을 할당한다.

인스턴스 반환

- 생성자 함수의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
- 만약 this가 아닌 다른 객체를 반환하면 this가 반환되지 못하고 retun문에 명시한 객체가 반환된다.
- `생성자 함수에 명시적으로 return문을 사용하는것은 기본 동작을 훼손하다. 지양해야할 부분이다.` 

```javascript
// 기본 생성자 함수.
function constructorFunction() {
  function Info(name, age) {
    const constant = 'constant';
    this.name = name;
    this.age = age;
    this.greeting = '안녕하세요';
    this.printInfo = function () {
      return `${greeting} \n 이름은:${this.name}이고, 나이는:${this.age}입니다.`;
    };
    
    // return 문을 명시하면 명시된 값이 출력된다.
    // ->{ name: 'kwon', age: 31 }
    // return { name, age };
  }
  const myInfo = new Info('kwon', 31);
  // this에 바인딩한 값들이 출력된다.
  //   Info {
  //   name: 'kwon',
  //   age: 31,
  //   greeting: '안녕하세요',
  //   printInfo: [Function (anonymous)]
  // }
  console.log(myInfo);
}
```

##### this 란?

|        함수 호출 방식        |                 this가 가르키는것                 |
| :--------------------------: | :-----------------------------------------------: |
|      일반 함수로서 호출      | 전역 객체 브라우저 환경: window/ node환경: global |
| 메서드로서 호출(객체 메서드) |               메서드를 호출한 객체                |
|     생성자 함수로서 호출     |           생성자 함수가 생성할 인스턴스           |

#### 내부 메서드 call과 construct

- 함수는 객체이지만 일반 객체와는 다르다. 일반 객체는 호출할 수 없지만 함수는 호출 할 수 있다.

- 함수가 일반 함수로서 호출되면 함수객체의 내부 메서드 call이 호출된다.

  - new 연산자와 함께 생성자 함수로써 호출되면 내부 메서드 construct가 호출된다.

- 모든 함수는 callable이지만 모든 함수 객체가 constructor인 것은 아니다.

- ```javascript
  function isConstructorFunction() {
    //  위 세가지 표현식만이 생성자 함수이다.
    function foo() {}
    const constFoo = function () {};
    // 프로퍼티의 값으로 할당된 함수는, 메서드가 아니다. 일반함수로 정의된 것이다.
    // 함수
    const obj = {
      x: function () {},
    };
    const newObj = new obj.x();
  
    // 생성자 함수가 아닌 함수
    // 생성자 함수가 아닌 함수를 new 연산자와 함께 사용하면 에러가 발생한다.
    const obj1 = {
      // 메서드
      met() {},
    };
    // 애로우 함수
    const t = () => console.log('t');
  }
  
  ```
  
- 일반 함수를 new 연산자와 사용하여 this또는 객체를 반환하지 않는다면 빈객체가 반환된다.

- New 연산자 없이 생성자 함수로 호출하면 일반 함수로 호출된다.

- ```javascript
  function newTarget() {
    function Info(name, age) {
      //  new 연산자없이 호출되었는지 확인하여 없이 호출하였다면, 재귀 호출한다.
      if (!new.target) {
        return new Info(name, age);
      }
      // 스코프 세이프 생성자 팬턴
      // new연산자와 함께 호출되면 this와 샘성자함수 객체는 프로토타입에 의해 연결된다.
      // 만약 일반함수처럼 호출된다면, this는 전역객체가 소유하고 있다.
      if (!(this instanceof Info)) {
        return new Info(name, age);
      }
      
      this.name = name;
      this.age = age;
      this.print = function () {
        return `이름은:${this.name}이고, 나이는:${this.age}입니다.`;
      };
    }
    // new연산자 없이 사용
    const user1 = Info('kim', 31);
    console.log(user1);
  }
  ```
  

#### 상속

상속은 객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 그대로 상속받아 사용할 수 잇는 것을 말한다.자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다.

모든 객체는 prototype 이라는 내부슬롯이 있고,이 내부 슬롯의 값은 프로토타입의 참조값이다.

```javascript
function checkProtoLevel(params) {
  function Info(name, age) {
    this.name = name;
    this.age = age;
    // 인스턴스 레벨의 함수
    // 각각의 객체마다 함수를 생성해서 가지고 았다. -> 메모리상 동일한 함수가 각각의 인스턴스에서 사용된다.
    this.printinfo = function () {
      return `name:${this.name}/age:${this.age}`;
    };
  }
  
  // 프로토타입의 함수를 생성하면, 프로타타입객체 레벨의 함수를 생성할 수 있다.
  // 이는 프로토타입 프토퍼티에 바인딩되어 사용할 수 있다.
  Info.prototype.printUser = function () {
    return `name:${this.name}/age:${this.age}`;
  };
  const kwon = new Info('kwon', 31);
  const kim = new Info('kim', 27);
  // 각각의 인스턴스는 다른 객체이다.
  // -> false
  console.log(kwon === kim);
  // 그러나 프로토타입 레벨의 함수는 공유되어 사용된다.
  // -> true
  console.log(kwon.printUser === kim.printUser);
  // 오버라이딩또한 가능하다.
  // -> 안녕하세요!! name:kwon/age:31
  kwon.printUser = function () {
    return `안녕하세요!! name:${this.name}/age:${this.age}`;
  };
}
```

각각의 인스턴스는 생성자 함수에 의해 prototype 속성을 상속받는다. 

![image-20220612224510412](/Users/khg/Library/Application Support/typora-user-images/image-20220612224510412.png)

##### 프로토타입 객체

프로토타입 객체란 객체지행 프로그래밍의 근간을 이루는 객첵 간 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 상위(부모)객체의 역할을 하는 객체로서 다른객체에 공유 프로퍼티를 제공한다. 프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.

- 모든 객체는 하나의 프로토타입을 갖는다. 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다



접근자 프로퍼티 `__proto__ `는 object.prototype의 프로퍼티다. 모든 객체는 상속을 통해 접근자 프로퍼티를 사용할 수 있다.

- get/set으로 이루어줘 있음

- Object.setPrototypeOf(obj, 상속받을 obj)을 통해 프로터타입을 교체 할 수 있다.

  

prototype 프로퍼티(속성)는 생성자 함수가 생성할 인스턴스 객체의 프로토타입을 가리킨다. **<u>따라서 생성자 함수만이 prototype을 소유한다.</u>**

|             구분             | 소유        | 값                | 사용주체    | 사용 목적                                                    |
| :--------------------------: | ----------- | ----------------- | ----------- | ------------------------------------------------------------ |
| `__proto__ ` 접근자 프로퍼티 | 모든객체    | 프로토타입의 참조 | 모든 객체   | 객체가 자신의 프로토타입에 접근 또는 교체하기 위해 사용      |
|      prototype 프로퍼티      | Constructor | 프로토타입의 참조 | 생성자 함수 | 생성자 함수가 자신이 생성할 객체 인스턴스의 프로토타입을 할당하기 위해 사용 |

모든 프로토타입은 constructor프로퍼티를 갖는다. 이 constructor 프로퍼티는 프로토타입 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.이 연결은 생성장 함수가 생성될 때, 즉 함수 객체가 생성될 때 이뤄진다.

- constructor가 가리키는 것은 생성자 함수이고, 생성자 함수는 인스턴스를 생성한 생성자 함수이다.

- 생성자 함수에는 자기자신의 프로퍼티가 정의되어 있고, 생성자함수에 의해 생성된 인스턴스는 prototype 프로퍼티을 통해 부모 속성을 사용할 수 있다.

리터럴 표기법으로 의해 생성된 객체는 생성자 함수로 생성된게 아닌다. 하지만 constructor와 연결되어 있다.

프로토타입 체인: 자바스크립트는 객체의 프로퍼티에 접근하려 할 때 해당 객체에 접근하려는 프로퍼타가 없다면, 내부슬롯 참조에 따라 자신의 부모 역할을 하는 프로퍼타입의 프로퍼티를 순차적으로 검색한다.

#### 정적 프로퍼티

생성자 함수 또한 객체임으로 자기자신의 속성값을 가질수 있다 이를 정적프로퍼티라 한다.인스턴스는 프로토타입 체인에 속하지 않는 정적메서드에는 접근이 불가하다.

```javascript
function testStatic(params) {
  function Obj(name) {
    const staticA = 'A';
    this.name = name;
  }
  Obj.staticB = 'B';
  const obj1 = new Obj('test1');
  // -> obj1.staticA:"undefined
  console.log(`obj1.staticA:"${obj1.staticA}`);
  // -> obj1.staticA:"undefined
  console.log(`obj1.staticb:"${obj1.staticB}`);
  // -> test1
  console.log(`obj1.staticb:"${obj1.name}`);
}
```

 

***

### 8.strice mode(엄격모드)

자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.

Eslint 같은 린트 도구를 사용해도 유사한 효과를 얻을 수 있다.린트 도구는 정적분석 기능을 통해 소스코드를 실행하기 전에 소스코드를 스캔하여 문법적 오류만이 아니라 잠재적 오류까지 찾아내고 오류의 원인을 리포팅해준다.





***

### 9.this 키워드

this는 자신이 속한 객체 또는 인스턴스를 가르키는 자기 참조 변수다.this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티와 메서드를 참조할 수 있다.this는 자바스크립트 엔진에 의해 암묵적으로 생성된다. 코드 어디서든 참조할 수 있다.`단 this가 가르키는 값, 즉 this의 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.`  

- 바인딩은 식별자와 값을 연결하는 과정이다.

  |        함수 호출 방식        |                      this가 가르키는것                       |
  | :--------------------------: | :----------------------------------------------------------: |
  |      일반 함수로서 호출      | 전역 객체 브라우저 환경: window/ node환경: global (엄격모드에서는 undefined다. ) |
  | 메서드로서 호출(객체 메서드) |                     메서드를 호출한 객체                     |
  |     생성자 함수로서 호출     |                생성자 함수가 생성할 인스턴스                 |

- this는 일반적으로 자기 참조 변수임으로, `strict mode가 적용된 일반 함수 내부의 this에서는 undefined가 반환된다.`  

#### 함수 호출방식과 this바인딩

this의 바인딩은 동적으로 결정된다.

- 렉시컬 스코프와 this바인딩의 결정시기는 다르다.

  - 렉시컬 스코프는 함수가 정의된곳 상위 스코프를 결정한다, 
  - 하지만 this 바인딩은 함수 호출 시점에 결정된다.
  - 런타임상 동적으로 바인딩된다.

- 일반 함수로 호출된 모든 함수(중첩함수,콜백함수) `내부의 this에는 전역 객체가 바인딩된다.`

- ```javascript
  var v = 100;
  function basicThis() {
    const obj = {
      v: 10,
      printV: function () {
        function innerF() {
          console.log(`중첨함수 에서 this는? ${this.v}`);
        }
        //일반함수로 호출 -> 전역변수 100
        innerF();
        console.log(`내부에서 this는? ${this.v}`);
      },
    };
    // 객체의 프로퍼티 메서드로 호출 ->10
    obj.printV();
  }
  basicThis();
  
  function dynamicBinding() {
    function Info(name) {
      this.name = name;
      this.printName = function () {
        console.log(`name:${this.name}`);
      };
    }
    const kwon = new Info('kwon');
    function printCallBack(callBack) {
      // -> name:undefined
      callBack();
    }
    printCallBack(kwon.printName);
  }
  ```
  
  ```javascript
  function bindThis() {
    const obj = {
      v: 10,
      t: 15,
      printV: function () {
        // 명시적으로 this를 바인딩.
        const that = this;
        function innerF() {
          // ->15
          console.log(`t는 ${that.t}`);
          // ->10
          console.log(`중첨함수 에서 this는? ${that.v}`);
        }
        innerF();
        console.log(`내부에서 this는? ${this.v}`);
      },
    };
    
    const obj1 = {
      v: 1,
      print() {
        // 화살표 함수 내부의 this는 상위 스코프의 this를 가르킨다.
        // 화살표 함수는 생성시 렉시컬 환경에서의 상위 this를 기억한다.
        setTimeout(() => console.log(this.v), 10);
      },
    };
    
    const obj2 = {
      v: 1,
      print() {
        // 바인드를 통해 this를 연결한다.
        setTimeout(
          function () {
            console.log(this.v);
          }.bind(this),
          10,
        );
      },
    };
    
    function Info(name) {
      this.name = name;
      this.printName = function () {
        console.log(`name:${this.name}`);
      };
      // 바인드를 통해 this를 연결한다.
      this.printName = this.printName.bind(this);
    }
    const kwon = new Info('kwon');
    function printCallBack(callBack) {
      callBack();
    }
    printCallBack(kwon.printName);
  }
  ```
  
- 

#### 동적으로 바인딩되는 This를 방지

- 객체의 메서드로 정의
  - 메서드 내부에서 this는 메서드를 호출한 객체(인스턴스)를 가르킴
  - 즉 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩 된다.
  - 주의할 점은 내부함수는 일반함수, 메소드, 콜백함수, 어디에서 선언되었던 관계없이 this는 전역객체를 바인딩합니다.
  
- 화살표 함수로 정의

- Apply,bind,call을 사용하여 명시적으로 바인딩 할 수 있다.

  

***

### 10.클래스

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/class

일반적으로 클래스란 사전에 정의된 속성 및 메소드들을 이용해 객체를 생성하기 위한 청사진이다.

자바스크립트는 프로토타입 기반 객체지향 언어이다. 클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만, 클래스는 생성자 함수보다 엄격하며 생성자 함수에서는 제공하지 않는 기능도 제공한다.

- new 연산자 없이 호출하면 에러발생
- 상속을 지원하는 extends와 super키워드를 제공
- 클래스는 호이스팅이 발생하지 않는것 처럼 동작한다.
- 암묵적으로 엄격모드가 적용된다.
- 클래싀의 생성자,프로토타입메서드,정적메서드는 모두 프로퍼티를 열거 할 수 없다.

#### 클래스 정의

클래스는 함수이며, 일급객체로 사용할 수 있다.

클래스 선언문으로 정의한 클래스는 함수 선운문과 같이 소스코드 평과 과정, 즉 런타임 이전 먼저 평가되어 함수 객체를 생성한다.

- 무명의 리터럴로 생성할 수 있다. 즉 런타임에 생성이 가능하다.
- 변수나 자료구조(객체,배열)에 저장할 수 있다.
- 함수의 매개변수에 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.

모든 함수객체가 가지고 있는 prototype 프로퍼티가 가리키는 프로토타입 객체의 constructor 프로퍼티 클래스 자신을 가르키고 있다.이는 클래스가 인스턴스를 생성하는 생성자 함수라는 것을 의미한다.

this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체를 가르킨다.

- 인스턴스의 프로퍼티를 사용할 경우 프로퍼티 레벨의 함수를 선언
- 만약 this를 사용하지 않을 경우 정적메서드로 정의

```javascript
function basicCalss(params) {
  class Info {
    // 클레스 레벨의 변수를 선얼할대는 static을 사용
    // 정적 변수
    static DESC = 'This is Info Class';
    // 접근 제어자 - 캡슐화
    // private(#) , public(기본), protected
    // private는 클래스 내부에서만 사용
    #name;
    #age;
    // 생성자
    // 인스턴스 생성 및 초기화
    // constructor 암묵적으로 this를 반환한다.
    // return this
    constructor(name, age) {
      this.#name = name;
      this.#age = age;
    }

    // 클래스 필드정의
    // 클래스 필드에 함수를 정의 할경우 인스턴스 레벨의 메서드이다.
    print = () => console.log(`name:${this.name}age:${this.age}`);
    getName = function () {
      return this.name;
    };
    // 프로토타입 레벨의 메서드
    print() {
      console.log(`name:${this.name}age:${this.age}`);
    }
  }

  const o1 = new Info('kown', 31);
  // 클레스 레벨의 변수는 인스턴스에서 사용 불가.
  // -> undefined
  console.log(o1.DESC);
  // Info { print: [Function: print], getName: [Function: getName] }
  console.log(o1);
  // console.log(o1.print());
}
```

```javascript
function getsetClass() {
  class Info {
    constructor(name, age) {
      this.name = name;
      this.age = age;
    }
    printInfo() {
      console.log(`name:${this.name}age:${this.age}`);
    }

    get ageInfo() {
      return this.name;
    }
    set ageInfo(age) {
      this.age = age;
    }
  }
  const kwon = new Info('kwon', 31);
  kwon.ageInfo = 25;
  console.log(kwon.ageInfo);
  console.log(Object.getOwnPropertyDescriptor(kwon));
}
// getsetClass();
function extendClass(params) {
  class Polygon {
    constructor(height, width, dimension) {
      this.name = 'Polygon';
      this.type = 'Figure';
      this.height = height;
      this.width = width;
      this.dimension = dimension;
      // this는 호출한 인스턴스가 가지고 있음.
      console.log(this);
    }
    calArea() {
      return this.height * this.width * this.dimension;
    }
    toString() {
      return this.name;
    }
  }

  class Square extends Polygon {
    static #D = 1;
    // new생성자 함께 클래스를 호출 할때 전달할 인수의 리스트.
    constructor(height, width) {
      // 수퍼클래스의 constructor를 호출하여 인스턴스를 생성 및 반환
      // super를 참조하면 수퍼클래스의 메서드를 호출 할 수 있다.
      super(height, width, Square.#D);
      this.name = 'Square';
      console.log(this);
    }
    // 오버로딩
    toString() {
      // 서브 클래스 메서드에서만 슈퍼클래스의 메서드를 참조 할 수 있다.
      // [[HomeObject]]를 가지는 함수
      console.log(super.toString());
      return super.toString() + this.height;
    }
  }
  const s1 = new Square(15, 15);
  console.log(s1);
  console.log(s1.calArea());
  console.log(s1.toString());
}
```

___

### 11.ES6 함수의 추가기능

es6 이전에 함수들은 동일한 함수여도 다양한 형태로 호촐이 가능했다. 

기본적으로 프로토타입 프로퍼티를 가지고 있어 실수를 유발할 수 있고, 성능면에서도 손해였다.

- 메서드 
  - 메서드의 경우 프로토타입 프로퍼티가 없고, 생성자 프로퍼티도 없다
  - 대신 super와 arguments는 존재한다.
  - super는 내부슬록 [[homeObject]]를 통해 호출되어 슈퍼클래스의 메서드를 상속받는다.
- 화살표 함수
  - 생성자 및 프로토타입 프로퍼티, 슈퍼, arguments 모두 없다. 
  - 화살표 함수는 함수 내부에서 this,arguments,super,new target을 참조하면 스코프 체인을 통해 상위 스코의 내용을 참조한다.
  - 화살표함수에서 함수자체의 this는 존재하지 않는다. 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. 이를 렉시컬 this라 한다. 이는 렉시컬 환경처럼 화살표 함수의 this가 **함수가 정의된 위치에 의해 결정된다.**

### 12.map과set

set객체는 중복되지 않는 유일한 값들의 집합이다

| 구분                              | 배열 | set  |
| --------------------------------- | :--: | :--: |
| 동일한 값을 중복하여 포함가능여부 |  o   |  x   |
| 요소 순서에 의미가 있다           |  o   |  x   |
| 인덱스 접근가능여부               |  o   |  x   |

map 객체는 키와 값의 쌍으로 이루어진 컬렉션이다. map객체는 객체와 유사 하지만 다음과 같은 차이점이 있다.

| 구분                   |          객체           |          map          |
| ---------------------- | :---------------------: | :-------------------: |
| 키로 사용할 수 있는 값 |    문자열 또는 심볼     | 객체를 포함한 모든 값 |
| 이터러블               |            x            |           o           |
| 요소 개수 확인         | Object.keys(obj).length |       map.size        |

map객체는 요소의 순서에 의미를 갖지 않지만, map객체를 순회하는 순서는 요소가 추가된 순서를 따른다.

> **`맵`이 키를 비교하는 방식**
>
> `맵`은 [SameValueZero](https://tc39.github.io/ecma262/#sec-samevaluezero)라 불리는 알고리즘을 사용해 값의 등가 여부를 확인합니다. 이 알고리즘은 일치 연산자 `===`와 거의 유사하지만, `NaN`과 `NaN`을 같다고 취급하는 것에서 일치 연산자와 차이가 있습니다. 따라서 맵에선 `NaN`도 키로 쓸 수 있습니다.
>
> 이 알고리즘은 수정하거나 커스터마이징 하는 것이 불가능합니다.
>
> #### 출처
>
> ___
>
> https://ko.javascript.info/map-set

***

### 13.클로저

클로저는 자바스크립트 고유의 개념이 아니라 함수를 일급객체로 취급하는 함수형 프로그래밍에서 사용되는 특성이다.

```javascript
function outerFunc() {
  const outerVars = '안녕하세요 아웃터환경의 변수에요!!';
  function innerFunc() {
    return outerVars;
  }
  return innerFunc;
}

const test = outerFunc();
// 안녕하세요 아웃터환경의 변수에요!!
console.log(test());

```

실행컨테스트상 outerFunc은 innerFunc을 반환하고 콜스택에서 제거된 상태이다. 하지만 test함수를 호출하면 이미 라이플사이클이 마감된 outerFunc함수의 지역변수인 outerVars에 접근하여 출력되는걸 볼 수 있다.

이처럼 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저(Closure)라고 부른다.

- 몇몇 프로그래밍 언어에서, 함수 안의 지역 변수들은 그 함수가 처리되는 동안에만 존재한다. 
- 실행컨테스트와 상관없이 렉시컬 환경은 기억되어 사용할 수 있다.

> 클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. 이 환경은 클로저가 생성된 시점의 유효 범위 내에 있는 모든 지역 변수로 구성된다.
>
> **춣처**
>
> https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures

```javascript
function multiples(x) {
  return (y) => {
    if (isNaN(y)) return;
    return x * y;
  };
}
const multiple3Fn = multiples(3);
const multiple5Fn = multiples(5);
// 50
console.log(multiple5Fn(10));
// 15
console.log(multiple3Fn(5));
```

즉 **클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수**를 말한다. 이를 조금 더 간단히 말하면 **클로저는 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수다라고 말할 수 있겠다.

- 클로저는 자신이 생성될 때의 환경(Lexical environment)을 기억해야 하므로 메모리 차원에서 손해를 볼 수 있다.

출처

https://poiemaweb.com/js-closure

https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures

---

### 기타정리 부분

#### 1.래퍼객체

문자열,불리언,숫자 등의 원시값에 문자열,숫자,블리언 객체를 생성하는 표준빑트인 생성자 함수가 있는이유?

- ```javascript
  function basicWraper(params) {
    const str = 'string?';
    //->7
    console.log(str.length);
    // ->STRING?
    console.log(str.toUpperCase());
  }
  ```

- 원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근허거나 메서드를 호출하고 다시 원시값으로 되돌린다.
- 이처럼 문자열,불리언,숫자 값에 대해 객체처럼 접근하면 생성되는 객체를 임시객체(래퍼객체)라 한다.

#### 2.전역객체

전역객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 가장 먼저 생성되는 특수한 객치에디.

- 브라우저 환경에서 전역객체

  - window,this,self,frames

- 노드 환경에서 전역객체

  - this.global

- 전역객체는 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체의 최상위 객체이다.

  - 이는 프로퍼타입 상속 관계상에서 최상위 객체라는 의미가 아니라, 계층적 구조상 표준 빑트인 객체와 호스트 객체를 프로퍼티로 소유한다는 것을 의미한다.

- 전역객체는 의도적으로 생성할 수 없다.

- 참조시 window,global등의 생략이 가능하다.

- 표준빌트인 객체를 프로퍼티로 가지고 있다.

- var키워드, 전역 함수는 전역 객체의 프로퍼티가 된다.

- Let,const는 전역객체의 프로퍼티가 아니다.이는 전역 레시컬 환경의 선언적 환경레코드 내에 존재한다.

- ```javascript
  var foo = 'foo';
  function basicWraper(params) {
    const str = 'string?';
    // console.log(str.length);
    // console.log(str.toUpperCase());
    // 해당 코드가 실행되면 암묵적전역으로 전역객체의 프로퍼티가 된다.
    y = 10;
  }
  basicWraper();
  // 브라우저에서는 window.foo가 출력됨.
  console.log(window.foo);
  // 암묵적 전역
  // 브라우저에서는 10이 출력된다.
  console.log(y);
  ```

  

#### 유사배열 객체

유사 배열 객체란 마치 매열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length 프로퍼티를 소유하고 있으며, for문을 통해 순회는 가능하다.

- 유사배열 객체임으로 배열 매서드는 사용 할 수 없다.

