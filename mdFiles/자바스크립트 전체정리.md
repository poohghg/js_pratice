JavaScript 통합 정리본

기본적인 JavaScript 문법을 정리해보자.

---

## 목차

[TOC]

---

정리 참조 사이트.

- https://developer.mozilla.org/ko/docs/Learn/JavaScript/First_steps/What_is_JavaScript
  - Mdn 공식문서
- https://ko.javascript.info/
- https://github.com/yjs03057/33-js-concepts
- https://velog.io/@jakeseo_me/series/33conceptsofjavascript



***



### 1.스크립트 로딩 전략

페이지의 모든 HTML은 순서 그대로 불러온다. JavaScript 를 사용해서 페이지 내의요소( [Document Object Model](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents#the_document_object_model))를 조작하려할때, HTMl의 요소보다 JAVASCRIPT파일을 먼저 불러와버리면 코드가 올바르게 동작하지 않을 수 있다.

- **고전적방식**

  - 고전적인 방법은 body 태그 후에 script 요소를 배치하는것이다. 모든 html을 읽은 후 에 스크립트를 불러와 실행한다.하지만 이 방식은 html dom을 모두 불러오기 전에는 스크립트 로딩과 분석이 완전히 중단 된다는 것이다. 실제 파일 수 가 많은 대형 사이트의경우 성능 정하를 야기시 킬 수 있다.

- #### async 와 defer

- **async**

  - async 특성을 지정하면 스크립트를 가져오는 동안 페이지는 로딩을 중단하지 않는다. 그러나 **스크립트 다운로드가 끝나면 바로 실행된다**. **실행도중에는 페이지 렌더링이 중단된다**. 스크립트의 실행 순서를 보장할 방법이 없는 방식이다.
  - 다른 스크립트에 의존하지 않는 독립 스크립트에 사용해야한다.

![img](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/What_is_JavaScript/async-defer.jpg)

```
<script async src="js/vendor/jquery.js"></script>

<script async src="js/script2.js"></script>

<script async src="js/script3.js"></script>
```

위코드를 실행시 html의 다운로드 실행순서를 보장 할 수 없다.

- async는 다수의 백그라운드 스크립트를 최대한 빠르게 불러와야 할 때 사용하면 이점이 있다.

**defer**

- defer 특성을 지정한 **스크립트는 페이지 내에 배치한 순서대로 불러오게 된다**. 또한 페이지 콘텐츠를 모두 불러오기 전까지는 실행하지 않는다. 페이지 요소를 수정하거나,추가하는 등의 DOM작업을 기대하는 스크립트에 유용한다.

```
<script defer src="js/vendor/jquery.js"></script>

<script defer src="js/script2.js"></script>

<script defer src="js/script3.js"></script>
```

**위 코드의** **경우 실행** 순서를 보장 받을 수 있으며, DOM이 그러져민 스크립트는 실행된다.

**요약**

- `async`와 `defer` 모두, 브라우저가 페이지의 다른 내용(DOM 등등)을 불러오는 동안 스크립트를 별도 스레드에서 불러오게 만듭니다(동시에 다운로드는 가능). 덕분에 스크립트를 가져오는 동안 페이지 로딩이 중단되지 않습니다.

- `async` 특성을 지정한 스크립트는 다운로드가 끝나는 즉시 실행합니다. 실행은 현재 페이지 렌더링을 중단하며, 실행 순서는 보장되지 않습니다.

- `defer` 특성을 지정한 스크립트는 순서를 유지한 채로 가져오며 모든 콘텐츠를 다 불러온 이후에 실행합니다.

- 의존성 없는 스크립트를 불러온 즉시 실행하려면 `async`를 사용하세요.

- 다른 스크립트에 의존하거나 DOM 로딩이 필요한 스크립트에는 `defer`를 사용하고, 원하는 순서에 맞춰서 `<script>` 요소를 배치하세요.

---



### 2.값과 자료형

자바스크립트 (ES6 기준) 는 7개의 타입이 있다. 6개의 원시타입과 1개의 객체타입이 존재한다.

원시타입관 객체타입의 구분 이유

- 원시타입의 값, 즉 원시값은 변경불가능한 값이다(immutable value)이다. 이에 비해 객체(참조)타입의 값, 즉 객체 는 변경가능한(mutable value) 값이다. 

- 원시 값은 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 이에 비해 객체를 변수(확보된 메모리 공간)에 할당하면 변수에는 참조값이 저장된다.
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 **값에 의한 전달**이라한다. 이에 비해 객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 **참조에 의한 전달**이라 한다.



변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다.

!!할당연산자는 값이 저장된 메모리 공간의 주소를 할당한다.

변수: 하나의 값을 저장하기 위해 확보된 메모리 공간(메모리 주소)

값: 변수에 저장된 데이터로서 표현식이 평가되어 생선된 결과

`변경 불가능하다는 것은 변수가 아니라 값이다.` 

- 원시 값은 변경불가능하다.하지만 변수는 언제든 재할당을 통해 변경가능하다.

  - 재할당이란 새로운 메모리 공간을 확보 할당 후, 변수는 새로운 원시값을 가리킨다.

- <img src="https://velog.velcdn.com/images%2Fmr_chu%2Fpost%2F6eec5b62-8105-483e-bfff-088b9318c8dd%2F%EB%B3%80%EC%88%98%20%EC%9E%AC%ED%95%A0%EB%8B%B9.jpeg" alt="변수 값의 할당과 재할당"  />

- 값에 의한 전달

  - 값의 의한 할당이 일어나면, 평가된 값은 같지만 할당된 메모리공간은 별개이다.

  - <img src="https://velog.velcdn.com/images%2Fsozero%2Fpost%2F67c6f130-24c3-4c35-b819-28b17ce9ed99%2F11%E1%84%80%E1%85%A1%E1%86%B9%E1%84%8B%E1%85%A6%E1%84%8B%E1%85%B4%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%83%E1%85%A1%E1%86%AF.png" alt="img" style="zoom: 67%;" />

  - ```javascript
      let score = 80;
      // score의값 80이 할당
      let copy = score
      // -> true
      console.log(score === copy);
      score = 100;
      // -> false
      console.log(score === copy);
    ```

    

#### 타입

- 정수(number) - 숫자 , 정수와 실수 구분 없이 하나의 숫자타입만 존재한다.

  - int,long,float,double 등과 같이 다앙햔 숫자 타입이 없다. **모든 수를 실수로 처리한다.** (정수를 표현하는 데이터 타입은 존재하지 않는다.)

  - 모두 10진수로 처리된다.

  - 숫자를 처리하는 특별한 값도 존재한다

    - Infinity : 양의 무한대

    - -Infinity : 음의 무한대

    - NaN : 산술 연산 불가

    - 대소문자를 구변함으로 NaN으로 표기

    - BigInt

      - 길이에 상관없이 정수를 나타낼수 있음

      - ```javascript
        // 끝에 'n'이 붙으면 BigInt형 자료입니다.
        const bigInt = 1234567890123456789012345678901234567890n;
        ```

- 문자형 (string) - 문자열은 따옴표로 묶는다.

  - 따옴표는 세 종류가 있습니다.
    1. 큰따옴표: `"Hello"`
    2. 작은따옴표: `'Hello'`
    3. 역 따옴표(백틱, backtick): `Hello`
  - 원시 타입으로 변경 불가능한 값이다.

- 불린형(논리 타입) - 불린형(논리 타입)은 `true`와 `false` 두 가지 값밖에 없는 자료형입니다.

- undefined

  - 변수를 선언 후 값이 할당되지 않는다면, 자바스크립트 엔진이 기본적으로 값을 할당하는 값.
  - 값이 현재 할당되지 않는 상태이다.
  - 변수에 undefined을 사용하는것 보다 null을 사용하자.

- null - null타입의 값은 null이 유일하다.

  - 값이 없다는것을 의도적으로 명시
  - 존재하지 않음, 비어있음을 명시

- 심벌 타입

  - 변경 불가능한 원시타입이다.

  - 심벌 값은 다른 값과 중복되지 않는 유일무일한 값이다.

  - 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용된다.

  - ```javascript
    const objKey = Symbol("obj");
    const obj = {};
    obj.objKey = objKey;
    ```

#### 데이터 타입에 의한 값의 해석

자바스크립트 엔진은 데이터 타입. 즉 값의 종류에 따라 정해진 크기의 메모리공간을 확보한다. 즉 변수에 할당되는 값의 데이터 타입에 따라 확보되어야 할 메모리 공간의 크기가 결정된다.

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정
- 값을 참조할때 읽어 들어야 할 메모리 공간의 크기를 결정
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정
  - 심벌테이블: 컴파일러 또는 인터프리터는 심벌테이블 이라고 부르는 자료 구조를 통해 식별자를 키로 바인된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.

#### 동적 타이핑

자바스크립트 변수는 선인이 아닌 할당(깂)에 의해 타입이 결정된다. 그리고 재할당(값의 변화)에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.

<> 정적타입(명시적 타입선언): 변수를 선언할때 데이터 타입을 선언 ex) java String name;

- 변수는 꼭 필요한 경우 제한적으로 사용한다.
- 변수의 유효범위(스코프)는 최대한 좁게 만들어 사용한다.
- 전역변수는 최대한 사용하지 않는다.
- 변수보다는 상수를 사용한다 `CONST 사용!!`
- 변수의 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.

#### 암묵적 형 변환

자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다.

자바스크립트 엔진은 표현식을 평가할때 코드의 문맥을 고려해 암묵적으로 데이터 타입을 강제 변환한다.

```javascript
const string_1 = "1";
const string_2 = "2";
const number_1 = 1;
const number_2 = 2;
// -> 12
console.log(string_1 + number_1);
// -> 12
console.log(string_1 + string_2);
// 3
console.log(number_1 + number_2);
// 1true -> string 으로 변환?
console.log(string_1 + true);
// 1false
console.log(string_1 + false);
// string
console.log(typeof (string_1 + true));
// -> 2 true는 number 1로 변환
console.log(number_1 + true);
// -> 1 fals는 number 0으로 변환
console.log(number_1 + false);
// -> 1 null은 number 0으로 변환
console.log(number_1 + null);
// NaN undefined은 숫자로 타입 변환되지 않는다.
console.log(number_1 + undefined);
// true 동등비교연산이 일어날 경우에도 자동 형변환이 일어난다.
console.log(string_1 == number_1);
// false 일치비교연산시는 자동형변환이 일이나지 않음(타입 및 값을 비교).
console.log(string_1 === number_1);
// 일치비교 연산시 팁!! -> false
// NaN은 isNaN 또는 object.is로 비교
console.log(NaN === NaN);

function checkTypeOf() {
  console.log("null ", typeof null);
  // null은 object로 반환한다. js의 버그이다.
  // type of 는  원시타입5개(null 제외) + object + function 총 7개 형태로 반환한다.
  // 함수의 타입은 function이다.
  // 배열은 유사배열 객체로 object 타입이다. 배열 확인은 Array.isArray()함수를 통해 확인.
  // null 타입은 반환하지 않는다.
  const temp = null;
  const obj = {};
  // temp의 타입은 object다.
  console.log("temp의 타입은 ? ", typeof temp);
  // false
  console.log(typeof temp === null);
  // true
  console.log(typeof temp === typeof obj);
  // true
  console.log(temp === null);
}
```

- 암묵적 타입 변환이 일어나는 조건식일때의 값
  - Falsy값
    - flase
    - undefined
    - null
    - 0,-0
    - NaN
    - '' (빈문자열)

### 3.유용한 연산자

#### 단축평가

||(논리핪) or &&(논리곱) 연산자 표현식의 평가결과는 불리언 값이 아닐 수도 있다. 두 연산자는 언제나 2개의 피연산중 어느 한쪽으로 평가된다. 왼쪽연산자 부터 시작해 오른쪽으로 나아가며 피연산자를 계산한다.

- || 연산자
  - 각 피연산자를 불린형으로 변환하여 평가한다음, true이면 평가를 멈추고 변환전 해당값 반환한다.
  - 모든값이 false로 평가되는 경우 변환전 마지막값을 반환한다.
- && 연산자 
  - 각 피연산자를 불린형으로 변환하여 평가한다음, false이면 평가를 멈추고 변환전 해당값 반환한다.
  - 모든값이 true로 평가되는 경우 변환전 마지막값을 반환한다.
  - 

| true \|\| anything  |   true   |
| :-----------------: | :------: |
| false \|\| anything | anything |
|  true && anything   | anything |
|  false && anything  |  False   |



```javascript
// 단축평가를 사용한 기본값 설정
function shortEvaluation(v) {
  // falsey한 값일 경우 우항의 값으로 취환된다.
  v = v || "notValue"
  console.log(v);
  return v
}

// 매개변수의 기본값 설정시
// 인자값이 null(값이 전달되지 않았을때) or undefined 인경우만 동작한다.
function isDefaultParams(v = "notValue") {
  console.log(v);
  return v
}

// -> notValue
shortEvaluation(NaN)

// -> undefined (기본값으로 취환되지 않음.)
isDefaultParams(NaN)

// arguments의 null은 notValu로 취환 -> notValue
isDefaultParams()

```



Nullish 병합 연산자 ??

- nullish의 경우 || 연산자와 비슷해보이지만 || 연산자의 경우 앞의 값이 `falsey`값인 경우 뒤의값을 취하지만 `?? 병합연사자의 경우 앞의 값이 null || undefined인 경우에만` 뒤의 값을 취한다. 

  ```javascript
  let height = 0;
  // 좌항의 값을 블리언으로 변환후 false이면 우항의값을 반환한다.
  alert(height || 100); // 100
  // 좌항의 값이 null 또는 undefined 이면 우항의값을 반환한다. 
  alert(height ?? 100); // 0
  ```

- 연산자 우선순위가 5로 낮기 때문에 괄호를 사용하자.

- 안정성 관련 이슈 때문에 `??`는 `&&`나 `||`와 함께 사용하지 못한다.

/ > `인용구`

#### 옵셔널 체이닝

?.연산자는 좌항의 피연산자가 null 또는 undefined 인경우 평가를 멈추고 undefined을 반환하고, 그렇지 않으면 우항의 프로퍼티 값을 참고한다.

- 이는 객체가 null 또는 undefined 아닌지 확인하고 객체의 프로퍼티를 참고할때 유용한다.

- ```javascript
  function checkFunction(obj) {
    console.log("user:",obj?.user); 
    console.log(obj?.printUser?.());
  }
  
  const info1 = {
    user:"kwon",
    printUser(){return this.user}
  }
  const info2 = {}
  // 실제 프로퍼티가 존재하기에 -> kwon이 찍힌다.
  checkFunction(info1)
  // 존재하지 않는 프로퍼티에 접근하였기에 undefined을 반환한다.
  // 옵셔널 체이닝을 사용하지 않았을경우 참조에러로 app crashed가된다.
  checkFunction(info2)
  
  ```

- 옵셔널 체이닝을 남발할 경우 초기에 에러를 발견하지 못하거나,디버깅이 어려워 질 수 있다.(필수값에는 사용하지 말자.)

- 참조하는 변수는 꼭 선언 되어 있어야한다!!!

  

***



### 4.객체

객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다. 객체는 원시타입 (immutable value)과는 다르게 다양한 타입의 값으로 구성된 복합적인 자료구조이다. 원시타입의 값은 변경 불가능하지만, **객체 타입의 값은 변경가능하다**. 자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다. 함수 또한 일급 객체 이므로 프로퍼티로 사용 할 수 있다. 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다.

- 객체 리터럴

  - 리터럴: 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법이다.


  ```javascript
  const info1 = {
    user:"kwon",
    printUser(){return this.user}
  }
  // 빈객채를 생성
  const info2 = {}
  ```

- **객체를 대괄호 연산자로 접근할 경우 반드시 따옴포로 감싼 문자열로 접근해야한다. `이는 자바스크립트 엔진이 식별자로 해석하기 때문이다.`**

  - 식별자는 값이 될수 있다.

- ```javascript
  // kwon
  console.log(info1["user"]);
  // error -> user is not defined
  const key1 = "user"
  // kwon
  console.log(info1[key1]);
  ```

- 객체의 접근경우 변수에 할당된 참조값에 의해 메모리에 접근하면, 참조값(참조 주소)은 객체가 저장된 메모리 공간의 주소이다.

  - 메모리에 저장되어 있는 참조값을 통해 실제 객체(데이터)에 접근한다.

  - 원시값의 변경불가능한 값으로, 재할당을 통해 값을 변경한다. `반면 객체는 변경 가능한 값이므로 메모리에 저장된 객체를 직접 수정할 수 있다.`

    - 객체에 할당한 변수의 참조값은 변하지 않는다.(하지만 참조값의 실제 데이터는 수정가능하다.)
    - 이는 객체를 복사해서 생성하는 비용을 절약하여 성능적 향상을 가져가기 위함이다.

  - ```javascript
    function checkObj() {
     const a = {
       name:"kown"
     }
     const b = a
     // true: 둘의 저장된 메모리는 다르지만 동일한 참조값을 바라본다.
     // 값에 의한전달.
     console.log(a===b);
     b.update = true
     // b의값이 변하면 a의값도 변한다.
     console.log(a);
     console.log(b);
      // a객체와 b객체는 같은 메모리 주소를 참고한다.
      // a -> { name: 'kown', update: true }
      // b -> { name: 'kown', update: true }
     console.log(a===b);
    }
    ```

  - 얕은 복사 vs 깊은복사

    - 객체를 프로퍼티 값으로 갖는 객체의 경우 얕은 복사는 한 단계까지만 복사하는 것을 말하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.

    - 얕은 복사로 만들어진 객체는 별개의 객체이다. 하지만 중첩되어 있는 객체의 경우 객체의 참조값을 복사한다.

    - 반면 깉은 복사의 경우 객체에 중첩되어 있는 객체까지 모수 복사하여 완전한 복사본을 만든다.

      - 깊은복사 방법
        - 재귀를 통한 방법
        - JSON.parse(JSON.stringify(obj));
          - JSON 문자열로 변환후 객체화 (느리다...)

        - [lodash](https://lodash.com/)의 메서드인 [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)을 사용
        - 참고 - https://ko.javascript.info/object-copy

    - ```javascript
      // 얕은복사
      const obj1 = {name:"kwon",isUpdate:false,keyList:["kwon",false,5],innerObj:{a:"aaa",b:"bbb"}}
      // 얕은복사 둘의 결과는 같다.
      const obj2 = Object.assign({},obj1)
      // const obj2 = {...obj1}
      // -> false 
      console.log(obj1 === obj2);
      // -> true 실제 중첩되어 있는 객체의경우에도 같은 참조값을 봐라본다.
      console.log(obj1.keyList === obj2.keyList);
      
      // 중복 객체의 경우 같은 참조값 가짐.
      obj1 :  {
        name: 'kwon',
        isUpdate: false,
        keyList: [ 'kwon', false, 5 ],
        innerObj: { a: 'aaa', b: 'bbb' }
      }
      
      obj2 :  {
        name: 'kwon',
        isUpdate: false,
        keyList: [ 'kwon', false, 5 ],
        innerObj: { a: 'aaa', b: 'bbb' }
      }
      
      // 깊은복사
      // 재귀를 통한 복사.
      function copy (_obj){
        const result = Array.isArray(_obj) ? [] : {}
      
        for (const key in _obj) {
          if(typeof _obj[key] === "object"){
            result[key] = copy(_obj[key])
          }else{
            result[key] = _obj[key];
          }
        }
        return result;
      }
      
      // lodash 사용
      const lodash = require("lodash");
      const obj2 = lodash.cloneDeep(obj1);
      const obj2 = copy(obj1);
      // -> false
      console.log(obj1.keyList === obj2.keyList);
      
      // 전개연산자를 통해 새로운 객체를 만들고 필요한 부분만 다시설정한다.
      const obj1 ={name:"k",num:5,list:[1,2,3]};
      const obj2 = {...obj1,num:10,list:[...obj1.list,10,20]};
      
      // ->{ name: 'k', num: 5, list: [ 1, 2, 3 ] } { name: 'k', num: 10, list: [ 1, 2, 3, 10, 20 ] }
      console.log(obj1,obj2);
      // false
      console.log(obj1 === obj2);
      
      
      
      ```


***

  

### 5.함수

함수는 객체타입으로 선언된 함수 이름은 함수 참조값 or 참조주소(힙 영역)에 의해 메모리에 접근한다.

- 객체의 접근경우 변수에 할당된 참조값에 의해 메모리에 접근하면, 참조값(참조 주소)은 객체가 저장된 메모리 공간의 주소이다(실제 데이터 영역).

- 함수는 함수명으로 호출되는 것이 아니라, 함수 객체를 가르키는 식볋자로 호출한다.

  - -자바스크립트는 함수명을 암묵적으로 할당함.

- ```javascript
  // 함수이름(매개변수,인자) -> parameter
  // 각 매개변수에는 함수를 호출할때 지정한 인수가 순서대로 할당된다.
  // 매개변수의 스코프는 함수내부.
  // arguments를 통해 인자값의 객체를 확인 할 수 있다.
  function  callFunction(a,b) {
    return a+b
  }
  // 인수(argument) -> 인수는 값으로 평가될 수 있는 표현식이여야 한다.
  callFunction(1,2)
  
  function fun_1(num) {
    return num; 
  }
  
  // 함수는 참조타입으로 변수에 함수식별자의 값(참조 주소)을 할당 한다.
  // 실행값 x -> 단지 변수(식별자)에 할당된 값(참조 주소)을 할당
  const getNum = fun_1;
  // -> true
  console.log(getNum === fun_1);
  
  
  ```

-  자바스크립트의 모든 선언문은 런타임 이전에 모두 생성된다.

  - 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체를 생성한다.

  ```javascript
  // -> error
  console.log(add(1,2));
  // 호이스팅
  // 실제호이스팅은 선언만 코드의 최상단으로 끌어올려줘 실행된다.
  console.log(isHosting());
  
  // 함수 선언문
  function isHosting() {
    return console.log("isHosting"); 
  }
  // 함수 표현식
  const add = function adds(x,y) {
    return console.log(x,y);
  }
  ```

- 함수는 가급적 한가지 일을 수행해야 한다.

- 매개변수의 갯수는 제한이 없지만, 최대한 적게 넘기는게 좋다.

- 키워드 인자값이 없고, 인수의 순서되로 할당되기에,객체를 만들어 키값에 접근하는 방식도 좋다.

- return문 -> 기본적으로 undefined을 반환

  - `return문을 만나면 함수는 종료된다.`


#### 화살표 함수

화살표 함수는 기존의 함수 선언문 또는 함수 표현식을 완전히 대체하기 위해 디자인된것은 아니다. 화살표 함수는 기존의 함수보다 표현만 간략한 것이 아니라 내부 동작 또한 간략화되어 있다.

- 생성자 함수로 사용할 수 없다.
- 기존 함수와 this 바인딩 방식이 다르다.
  - 함수 선언시 선언된 상위 렉시컬환경의 this를 바인딩한다..

- Prototype 프로퍼티가 없다.
- arguments 객체를 생성하지 않는다.

#### 일급객체(일급함수)

함수를 값처럼 자유롭게 사용할 수 있다.

- 일급객체의 조건
  - 무명의 리터럴로 생성할 수 있다.즉, 런타임에 생성이 가능하다.
  - 변수나 자료구조에(객체,배열)에 저장할 수 있다.
  - 함수의 매개변수에 전달할 수 있다.
  - 함수의 반환값으로 사용할 수 있다.

- 일반 객체처럼 모든 연산이 가능한것
  - 함수를 매개변수로 전달할 수 있음. -> 함수의 참조값 전달
  - 함수를 반환값 으로 사용할 수 있음.
  - 함수를 변수에 할당 할 수 있음(함수 표현식).
  - 동일비교 대상
  - 객체의 프로퍼티값이 될 수도 있으며, 배열의 요소가 될 수 있다.

함수가 일급 객체라는 것은 함수를 객체와 동일하게 사용할 수 있다는 의미다.

그러나 일반객체는 호출할 수 없지만, 함수 객체는 호출할 수 있다.그리고 함수 객체는 일반 객체에는 없는 함수 고유의 프로퍼티를 소유한다.

```javascript
// ->undefined __proto__는 함수의 프로퍼티가 아니다.
// 배열
//console.log(Object.getOwnPropertyDescriptor(firstClassObject, '__proto__'));
// 함수의 프로퍼티
console.log(Object.getOwnPropertyDescriptors(firstClassObject));
```

![image-20220610222217657](/Users/khg/Library/Application Support/typora-user-images/image-20220610222217657.png)

```javascript
function confirmFuncionProto(a) {
  // arguments는 유사배열 객체이다.
  // 함수 호출시 전달된 인수이다.
  // 매개변수와 일치하지 않는다.
  // -> [Arguments] { '0': 1, '1': 2, '2': 3, '3': 4, '4': 5 }
  console.log(arguments);
  // 만약 초과된 인수는 undefined으로 초기화된다.
  
  // rest나 전개연산자로 배열화가능.
  console.log([...arguments]);
}

```

- 유사배열 객체와 이터러블

  - es6에서 도입된 이터레이션 프로토콜을 준수하면, 순회 가능한 자료구조인 이터러블이 된다.
  - 유사배열 객체는 배열이 아니다, 배열 메서드를 사용할 경우 에러가 발생한다.
  - call 또는 apply을 적용하거나 loop 메서드를 사용

- 함수객체의 name

  - 기본적으로 함수의 이름을 나타낸디.

  - es6 에서는 익명함수 객체를 가리키는 식별자를 값으로 갖는다.

  - 함수 이름과 함수 객체를 가르키는 식별자는 의미가 다르다. 함수를 호출할 때는 함수 이름이 아닌 함수 객체를 가르키는 식별자로 호출한다.

  - ```javascript
    const confirmF = confirmFuncionProto;
    const nameF = () => {};
    // -> confirmFuncionProto
    console.log(confirmF.name);
    // -> nameF
    console.log(nameF.name);
    ```

#### 고차함수

- 인자로 함수를 받음(콜백함수)
  - 함수를 인자로 받아 함수를 합성하여 사용.
  - 함수의 공통로직은 두고 액션 함수에 따라 목적에 맞게 사용 할 수 있다.
  - 콜백함수는 함수형 프로그램의 기본패러다임 일뿐 아니라, 비동기 처리(이벤트처리,Ajax통신, 타이머 함수)의 중요패턴 중 하나이다.
- 함수를 반환하는 함수

#### 순수함수

함수형 프로그래밍에서 어떤 외부 상태에 의존하지 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수라한다.

- 외부 상태에 의존하지 않고, 오직 매개변수를 의존해 값을 생성한다.
- 최소 하나의 인수를 전달받아 동일한 값을 반환한다.

#### 불변성 

함수내부에서 외부로부터 주어진 인자의 값을 변경하는것은 추천하지 않는다.

- 원식 타입의 경우(변경불가능) 재할당을 통해 값을 변경하기에 상관없음.
- 반면 객체 타입의 경우 참조에 의한 전달이기에 언제든 객체데이터의 변경이 가능하다.
- 객체의 경우 참조에 의한 복사임으로 외부로부터 주어진 객체를 함부로 변경하지말자.
  - 객체변경에 따른 코드추적이 어려워 질수 있다.

- 상태 변경이 필요한 경우에는, 새로운 객체를 만들어서 반환해야함.

- ```javascript
  function chageObjNum(obj) {
    // 얕은복사로 새로운 객체를 만들고 필요값을 변경하자.
    return {...obj,num:2} 
  }
  const obj1 ={name:"k",num:5};
  // -> name:"k",num:2
  const obj2 = chageObjNum(obj1);
  ```

#### 중첩함수

함수 내부에 정의된 함수. 중첩 외부 함수 스코프 내에서만 호출 할 수 있다. 일반적으로 중첩함수는 외부함수를 돕는 헬퍼 함수의 역할을 한다.

```javascript
function outerFuncion(arr){
  // 함수안의 헬퍼함수를 만들어 함수 스코프 내부에서 사용할 수 있다.
  function multiply(a){
    return a * 2
  }
  return arr.map((v)=>multiply(v))
}
// -> [ 2, 4, 6, 8, 10 ]
console.log(outerFuncion([1,2,3,4,5])); 
```

***



### 6.스코프(Scope)

스코프는 변수,함수,클래스이름(식별자)의 유효한 범위이다(실행 컨택스트). 이는 선언된 위치에 따라 유효범위가 결정된다. 스코프의 범위는 블럭 안에서만 유효하다. 스코프는 식별자가 유효한 범위를 말한다.

- 스크프의 종류
- 전역: 코드의 가장 바깥 영역 (전역변수)
- 지역: 함수 몸체 내부 (지역변수)

> 현재 실행 컨텍스트입니다. [값](https://developer.mozilla.org/en-US/docs/Glossary/Value) 과 **표현식** 이 "표시"되거나 참조될 수 있는 컨텍스트입니다 . 변수 또는 기타 표현식이 "현재 범위에" 있지 않으면 사용할 수 없습니다.범위는 계층 구조로 계층화될 수도 있으므로 하위 범위가 상위 범위에 액세스할 수 있지만 그 반대는 불가능합니다.
>
> **[함수](https://developer.mozilla.org/en-US/docs/Glossary/Function)** 는 [JavaScript](https://developer.mozilla.org/en-US/docs/Glossary/JavaScript) 에서 **클로저** 역할을 하므로 범위를 생성하므로 (예를 들어) 함수 내에서만 독점적으로 정의된 변수는 함수 외부 또는 다른 함수 내에서 액세스할 수 없습니다.
>
> ---https://developer.mozilla.org/en-US/docs/Glossary/Scope

```javascript
function basisScope() {
  // 지역변수는 자신의 스크포와 하위 스코프에서 사용 가능하다.
  const outer = 'test';
  {
    const inner = 'inner';
    // 상위 스코프 변수에 접근가능
    console.log(outer);
  }
  // 같은 스크프에 있는 변수 
  console.log(outer);
  // 하위 스코프 변수에 접근 불가능
  //-> 접근 불가
  // console.log(inner);
}
```

코드 블록이 정의되는곳

If, for,{},function(){},switch, try...*catch*문

- 이름 충돌방지
  - 유효범위를 가짐으로써 식별자의 충돌을 막을 수 있다.
  - 스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용 할 수 있다.

- 메모리 절약

#### 렉시컬 환경

코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 렉시컬 환경이라고 한다.즉 코드의 문맥은 렉시컬 환경으로 이뤄진다.이를 구현한것이 실행 컨텍스트이며, 모든 코드는 실행 컨택스트에서 평가되고 실행된다.

- 렉시컬 스코프 또는 정적 스코프 : 함수를 어디서 정의했는지에 따라 함수의 상위스코프를 결정한다.이는 함수정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다.
- 함수가 정의된 스코프에서 상위 스코프를 결정.

```javascript
// 렉시컬 스코프: 함수의 선언된 위치에 따라 상위 스코프를 결정
function checkScope() {
  let x = 1;

  function foo(params) {
    let x = 10;
    //-> 10
    console.log(`foo의 x는${x}`);
    // 함수의 호출 스코프와 상관없이 함수가 선언된 스코프에서 동작
    // 스코프체인시 함수의 상위 스코프 x의값(1)를 참조한다.
    bar();
  }

  function bar(params) {
    // -> 1이 출력
    console.log(`bar의 x는${x}`);
  }
  foo();
}
```

- 각각의 블록은 렉시컬 환경을 가지고 있다.
  - 환경레코드
  - 외부 환경 참조(이는 내부스코프에서 스코프 체인을 통해 외부 레시컬 환경에 접근할 수 있기 때문이다.)
  - 스코프 체인: 스코프가 계층적으로 연결된 형태
  - 자바스크립트 엔진은 스코프체인을 통해 변수를 참조하는 스코프에서 시작하여 상위로 이동 (단방향 연결)하며 선언된 변수를 검색 한다. 
  - ![스코프 체인과 클로저](https://images.velog.io/images/rlatmdgns94/post/d1b27a4f-c73b-4515-8264-e2605f5636b2/_.png)



#### GC

메모리 생명주기

1.필요한 메모리 할당

2.할당된 메모리 사용(읽기,쓰기)

3.더 이상 필요하지 않을 때 할당된 메모리 해제

> JavaScript는 객체가 생성될 때 자동으로 메모리를 할당하고 더 이상 사용되지 않을 때 해제합니다( *가비지 수집* ). 이러한 자동성은 잠재적인 혼란의 원인입니다. 개발자에게 메모리 관리에 대해 걱정할 필요가 없다는 잘못된 인상을 줄 수 있습니다.
>
> ### [값 사용](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#using_values)
>
> 값을 사용한다는 것은 기본적으로 할당된 메모리에서 읽고 쓰는 것을 의미합니다. 이는 변수 또는 객체 속성의 값을 읽거나 쓰거나 함수에 인수를 전달하여 수행할 수 있습니다.
>
> ### [메모리가 더 이상 필요하지 않을 때 해제](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#release_when_the_memory_is_not_needed_anymore)
>
> 대부분의 메모리 관리 문제는 이 단계에서 발생합니다. 이 단계에서 가장 어려운 부분은 할당된 메모리가 더 이상 필요하지 않은 시점을 결정하는 것입니다.
>
> 저수준 언어는 개발자가 프로그램에서 할당된 메모리가 더 이상 필요하지 않은 지점을 수동으로 결정하고 해제해야 합니다.
>
> JavaScript와 같은 일부 고급 언어는 [가비지 수집](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)) (GC)으로 알려진 자동 메모리 관리 형식을 활용합니다. 가비지 수집기의 목적은 메모리 할당을 모니터링하고 할당된 메모리 블록이 더 이상 필요하지 않은 때를 결정하고 이를 회수하는 것입니다. 이 자동 프로세스는 특정 메모리 조각이 여전히 필요한지 여부를 결정하는 일반적인 문제를 결정할 수 없기 때문에 근사치 [입니다](https://en.wikipedia.org/wiki/Decidability_(logic)).
>
> 참조
>
> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management
>
> 



- 전역변수와 지역변수
  - 전역변수의 생명주기는 애플리케이션의 생명주기와 같다
  - `함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료되면 소멸한다.` 
  - 변수는 하나의 값을 저장하기 위해 확보된 메모리 공간 자체이다. 변수의 생명주기는 메모리공간 확보 -> 해제 -> 메모리 풀에 반환 까지이다.
- 전역변수의 문제점
  - 암묵적 결합:코드를 어디에서든 참조하고 할당할 수 있다는것을 의미한다.
    - 변수의 유효범위가 클수록 코드의 가독성은 나뻐지며,의도치 않게 상태가 변경될 수 있다.
  - 긴 생명주기
    - 메모리 리소스도 오랜 기간 소비한다.
    - 만약 var키워드를 사용한다면 의도치 않는 재할당이 일어날수 있다.
    - 파일이 분리되어 있다해도. 변수가 공유된다는 것이다. 이는 다른 파일내에서 동일한 이름으로 망명된 전역변수나 전역 함수가 같은 스코프 내에 존재할 경우 예기치 못한 결과를 가져올 수 있다.

#### 호이스팅

자바스크립트 엔진이 코드를 실행하기 전, 변수,함수,클래스의 선언문을 코드 최상단으로 끌어올리는것

- 런타임 이전에 변수는 할당이된다.

변수의 선언과 초기화를 분리한 후, 선언만 코드의 최상단으로 옮김

- ```javascript
  function checkHoisting(params) {
    // 함수의경우 호이스팅으로 실행된다.
    hoisting();
    // ReferenceError: Cannot access 'checkVar' before initialization
    // console.log(checkVar);
    // ReferenceError: Cannot access 'hoistingFunction' before initialization
    // hoistingFunction();
  
    // let,const,클래스
    // 선언만 호이스팅이되고, 초기화는 되지 않는다.
    // 초기화전 변수에 접근하면 컴파일 에러가 발생한다.
  
    // 만약 var를 사용했다면 undefined이 찍힌다.
    function hoisting() {
      const test = 'test';
    }
  
    const checkVar = 'checkVar';
    const hoistingFubction = hoisting;
  }
  ```

#### var키워드의 문제점	

- 중복선언이 가능하다

- 오로지 함수의 코드 블록만을 지역스크프로 인정한다.따라서 함수 외부에서 var키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.
  - var키워드로 선언한 전역 변수의 생명주기는 전역 객체의 생명주기와 일치하다.
  
- 변수 호이스팅에 의해 초기 undefined값이 할당된다.

- ```javascript
  function checkVar() {
    // 실제 초기화전 undefined이 할당된다.
    // -> undefined
    console.log(i);
    var i = 't';
    // -> t
    console.log(i);
    for (var i = 0; i < 2; i++) {
      // 1,2
      console.log(i);
    }
    
    // 현재 함수코드 블록에서 전체에서 공유되어 사용된다.
    console.log(`for문 바깥스코프의 i ${i}`);
  
    var i = '이상해';
    console.log(`var는 재선언 재할당도 가능하다. ${i}`);
    {
      var t = 't';
    }
    // 하위 스코프에 선언된 변수도 사용가능하다....
    // -> t
    console.log(t);
  }
  // !!error -> 오로지 함수의 코드 블록만을 지역스크프로 인정한다
  console.log(t);
  
  ```

- let 버전

- ```javascript
  // 함수 블록내 i변수와 전역스코프에 선언된 i변수는 다른변수이다.
  let i="globalT"
  function checkLet() {
    // !!error
    // Cannot access 'i' before initialization
    // console.log(i);
    let i = 't';
    // -> t
    console.log(i);
    // for문의 블록 레벨 스코프
    for (let i = 0; i < 2; i++) {
      // 1,2
      console.log(i);
    }
    // -> t
    console.log(`for문 바깥스코프의 i ${i}`);
  
    {
      let t = 't';
    }
    // !!error
    // t is not defined
    // 현재 렉시컬환경에 t라는 변수는 존재하지 않는다.
    console.log(t);
  }
  ```

  

#### let과 const

- 모든 코드블록을 지역스코프로 인정한다(일반적인 프로그래밍의 코드블록).

- 선언 단계와 초기화 단계가 분리되어 진행된다.

  - 런타임 이전에 자바스크립트 엔젠에 의해 암묵적으로 선언단계가 먼저 실행되고, 초기화 단계는 변수 선언문에 도달했을때 실행된다.

  - 호이스팅이 일어나지 않는거 같지만 실제로는 일어나며 선언단계 <-> 초기화 단계 사이 일시적 `사각지대영역`이 있다.

  - ```javascript
    function checkLetHoisting() {
      let isHoisting = '?';
    
      function check() {
        // Cannot access 'isHoisting' before initialization
        // 이는 함수 스코프내에서 호이스팅이 일어나 렉시컬체인 상위의 let으로 선언된 isHoisting 변수를 참조하지 않는다.
        console.log(isHoisting);
        const isHoisting = true;
      }
      check();
    }
    ```

  - 키워드로 선언한 변수는 전역객체(브라우저 에서는 window)의 프로퍼티가 아니다.

  - ```javascript
    var tt = 'tttttt';
    let cc = 'cccccc';
    // -> tttttt
    console.log(window.tt);
    // -> undefined
    console.log(window.cc);
    ```

  - let은 재선언이 불가하면 재할당은 가능하다.

  - const은 재선언 재할당 둘다 불가능하다.

    - const는 선언과 함깨 값을 할당해주어야 한다.
    - 상수처럼 사용가능하다.
      - 원시값을 할당할 경우 -> 원시 값은 변경 불가능한 값이므로
    - 객체를 할당할 경우 값을 변경 할 수 있다.
      - 실제 참조주소는 변경되지 않지만, 참조된 객체의 값은 변경가능하다.

+++

### 7.프로토타입(prototype)

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties

<u>**자바스크립트는 명령형,함수형,프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다.**</u>

**<u>자바스크립트는 객체기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 원식타입을 제외한 모든값들은 객체로 구성되어 있다.</u>**



자바스크립트의 모든 객체는 객체간 상속을 위해 object라는 내부의 prototype 가지고 있다.

- 자바스크립트의 내장된 기본 상태 및 함수이다.
- 직접 접근은 불가하지만, 내부슬롯의 경우 `__proto__` 접근자 프로퍼티를 통해 간접적으로 접근할 수 있다.

자바스크립트에서 객체간 상속의 연결고리는 프로토타입 체인으로 연결되어 있다

- 배열 -> array -> object



자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 속성을 기본값으로 자동정의한다.

#### 데이터 프로퍼티: 키와값으로 구성된 일반적인 프로퍼티.

- value: 객체속성의 값
- writable: 값을 변경할수 있을지의 유무(값의 갱신 가능 여부)
- enumerable: 속성을 열거가능한지
  - -false 인경우 in, Object 문의 열거함수로 열거 할 수없다.

- configurable: 속성이 삭제될수 있는지유무(재정의 가능 여부)

```javascript
const obj1 = {
  name: 'kwon',
  age: 31,
  desc() {
    return `age:${this.age},name:${this.name}`;
  },
};
// 객체의 권한을 수정해서 객체를 관리 할 수 있다.
Object.defineProperties(obj1, {
  name: {
    writable: false,
  },
  age: {
    value: 29,
    enumerable: false,
  },    
}); 
/**
{
  name: {
    value: 'kwon',
    writable: false,
    enumerable: true,
    configurable: true
  },
  age: { value: 29, writable: true, enumerable: false, configurable: true },
  desc: {
    value: [Function: desc],
    writable: true,
    enumerable: true,
    configurable: true
  }
*/
console.log(Object.getOwnPropertyDescriptors(obj1));


```

#### 접근자 프로퍼티

접근자 프로퍼티는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할때 사용하는 접근자 함수로 구성된다.

- ```javascript
  // 접근자 프로퍼티
  function accesoorProtp() {
    const user = {
      name: 'kwon',
      age: 31,
      get ageInfo() {
        return `${this.age}`;
      },
      set ageInfo(age) {
        this.age = age;
      },
    };
  
    // setter 호출
    user.ageInfo = 33;
    // getter 호출
    console.log(user.ageInfo);
  }
  ```

#### 프로퍼타입

프로퍼타입은 어떤 객체의 상위 객체의 역할을 하는 객체다. 프로퍼타입은 하위 객체에게 자신의 프로퍼티와 메서드를 상속한다. 하위 객체는 상위 프로퍼타입의 프로퍼티 또는 메서드를 사용 할 수 있다. 프로퍼타입 체인은 단방향 링크드 리스트 형태로 구성되어 있다. 객체나 메서드에 접근하려 할때 해당 객체의 프로퍼티 또는 메서드가 없다면, 프로퍼타입 체인을 따라 상위 프로퍼타입을 검색한다.

프로토타입 확인해보기

- ```javascript
  function checkProtoLevel(params) {
    function Info(name, age) {
      this.name = name;
      this.age = age;
      // 인스턴스 레벨의 함수
      // 각각의 객체마다 함수를 생성해서 가지고 았다.
      // 메모리상 비효율적.
      // this.printinfo = function () {
      //   return `name:${this.name}/age:${this.age}`;
      // };
    }
    // 프로토타입의 함수를 생성하면, 프로타타입레벨의 함수를 가질수 있다.
    Info.prototype.printUser = function () {
      return `name:${this.name}/age:${this.age}`;
    };
    const kwon = new Info('kwon', 31);
    const kim = new Info('kim', 27);
    console.log(kwon);
  }
  ```
  
  
  
- <img src="/Users/khg/Library/Application Support/typora-user-images/image-20220607230608685.png" alt="image-20220607230608685"  />

  #### 객체변경방지

  - ```javascript
    // 오브제트 프리징 -> 값의 읽기만 가능 나머지는 모두불가.
    // 객체를 동결시킨다.
    function immutabilityObj() {
      // 오브젝트 동결시키기
      const obj = {
        name: 'kwon',
        age: 31,
        inner: {
          a: 'a',
          b: 'b',
        },
      };
      // Prevents the modification of existing property attributes and values, and prevents the addition of new properties.
      // 기존 프로퍼티의 속성(키)과 값을 수정(삭제,쓰기,재정의)을 방지하고, 새로운 속성을 추가하는것을 방지한다.
    
      Object.freeze(obj);
      // age: { value: 31, writable: false, enumerable: true, configurable: false }
      // console.log(Object.getOwnPropertyDescriptors(obj));
      // 무시!!!!
      delete obj.name;
      obj.name = 'hi!';
      obj.plus = '+';
      // freeze도 얕은복사이다. 내부객체는 변경가능하다.
      // freeze시 내부 객체의 경우 같은 참조값을 보고있다. 참조 객체의 값을 수정하면 같이 변경된다.
      obj.inner.a = 'AA';
      // -> { name: 'kwon', age: 31, inner: { a: 'AA', b: 'b' } }
      console.log(obj.iss);
      console.log(obj);
    }
    ```

  - ```javascript
    // 오브제트 seal -> 기본 오브젝트의 형태를 유지하지만, 값의 수정은 가능하다.
    function sealObj() {
      const obj = {
        name: 'kwon',
        age: 31,
        inner: {
          a: 'a',
          b: 'b',
        },
      };
      //Prevents the modification of attributes of existing properties, and prevents the addition 	of new properties.
      // 속성은 변경불가 !! 값의 수정은 가능하다.
      Object.seal(obj);
      obj.name = 'HI!';
      delete obj.name;
      // -> { name: 'HI!', age: 31, inner: { a: 'a', b: 'b' } }
      console.log(obj);
      // seal되었는지 확인하다.
      // console.log(Object.isSealed(obj));
    }
    ```

  - 중첩객체(얕은방지)로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지 못한다. 재귀적으로 호출하여 freeze하자. 



#### 생성자 함수

객체 리털리에 의한 객체생성 방식은 단 하나의 객체만 생성한다. 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야하기에 비효울적이다.

생성자함수 : 객체(인스턴스)를 생성하는 함수.

일반함수와 같이 정의하고, new 연산자와 함께 생성자 함수를 호출한다.

- 인스턴스 생성과 this바인딩: 암묵적으로 빈 객체를 생성한다. -> 인스턴스는 this에 바인딩된다.
- 다음 과정은 함수실행 이전 런타임에 실행된다.

인스턴스 초기화 

- this에 바인딩되어 있는 인스턴스에 프로퍼티나 메서드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 할당하여 초기화하거나 고정값을 할당한다.

인스턴스 반환

- 생성자 함수의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
- 만약 this가 아닌 다른 객체를 반환하면 this가 반환되지 못하고 retun문에 명시한 객체가 반환된다.
- `생성자 함수에 명시적으로 return문을 사용하는것은 기본 동작을 훼손하다. 지양해야할 부분이다.` 

```javascript
// 기본 생성자 함수.
function constructorFunction() {
  function Info(name, age) {
    const constant = 'constant';
    this.name = name;
    this.age = age;
    this.greeting = '안녕하세요';
    this.printInfo = function () {
      return `${greeting} \n 이름은:${this.name}이고, 나이는:${this.age}입니다.`;
    };
    
    // return 문을 명시하면 명시된 값이 출력된다.
    // ->{ name: 'kwon', age: 31 }
    // return { name, age };
  }
  const myInfo = new Info('kwon', 31);
  // this에 바인딩한 값들이 출력된다.
  //   Info {
  //   name: 'kwon',
  //   age: 31,
  //   greeting: '안녕하세요',
  //   printInfo: [Function (anonymous)]
  // }
  console.log(myInfo);
}
```

##### this 란?

|        함수 호출 방식        |                 this가 가르키는것                 |
| :--------------------------: | :-----------------------------------------------: |
|      일반 함수로서 호출      | 전역 객체 브라우저 환경: window/ node환경: global |
| 메서드로서 호출(객체 메서드) |               메서드를 호출한 객체                |
|     생성자 함수로서 호출     |           생성자 함수가 생성할 인스턴스           |

#### 내부 메서드 call과 construct

- 함수는 객체이지만 일반 객체와는 다르다. 일반 객체는 호출할 수 없지만 함수는 호출 할 수 있다.

- 함수가 일반 함수로서 호출되면 함수객체의 내부 메서드 call이 호출된다.

  - new 연산자와 함께 생성자 함수로써 호출되면 내부 메서드 construct가 호출된다.

- 모든 함수는 callable이지만 모든 함수 객체가 constructor인 것은 아니다.

- ```javascript
  function isConstructorFunction() {
    //  위 세가지 표현식만이 생성자 함수이다.
    function foo() {}
    const constFoo = function () {};
    // 프로퍼티의 값으로 할당된 함수는, 메서드가 아니다. 일반함수로 정의된 것이다.
    // 함수
    const obj = {
      x: function () {},
    };
    const newObj = new obj.x();
  
    // 생성자 함수가 아닌 함수
    // 생성자 함수가 아닌 함수를 new 연산자와 함께 사용하면 에러가 발생한다.
    const obj1 = {
      // 메서드
      met() {},
    };
    // 애로우 함수
    const t = () => console.log('t');
  }
  
  ```
  
- 일반 함수를 new 연산자와 사용하여 this또는 객체를 반환하지 않는다면 빈객체가 반환된다.

- New 연산자 없이 생성자 함수로 호출하면 일반 함수로 호출된다.

- ```javascript
  function newTarget() {
    function Info(name, age) {
      //  new 연산자없이 호출되었는지 확인하여 없이 호출하였다면, 재귀 호출한다.
      if (!new.target) {
        return new Info(name, age);
      }
      // 스코프 세이프 생성자 팬턴
      // new연산자와 함께 호출되면 this와 샘성자함수 객체는 프로토타입에 의해 연결된다.
      // 만약 일반함수처럼 호출된다면, this는 전역객체가 소유하고 있다.
      if (!(this instanceof Info)) {
        return new Info(name, age);
      }
      
      this.name = name;
      this.age = age;
      this.print = function () {
        return `이름은:${this.name}이고, 나이는:${this.age}입니다.`;
      };
    }
    // new연산자 없이 사용
    const user1 = Info('kim', 31);
    console.log(user1);
  }
  ```
  

#### 상속

상속은 객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 그대로 상속받아 사용할 수 잇는 것을 말한다.자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다.

모든 객체는 prototype 이라는 내부슬롯이 있고,이 내부 슬롯의 값은 프로토타입의 참조값이다.

```javascript
function checkProtoLevel(params) {
  function Info(name, age) {
    this.name = name;
    this.age = age;
    // 인스턴스 레벨의 함수
    // 각각의 객체마다 함수를 생성해서 가지고 았다. -> 메모리상 동일한 함수가 각각의 인스턴스에서 사용된다.
    this.printinfo = function () {
      return `name:${this.name}/age:${this.age}`;
    };
  }
  
  // 프로토타입의 함수를 생성하면, 프로타타입객체 레벨의 함수를 생성할 수 있다.
  // 이는 프로토타입 프토퍼티에 바인딩되어 사용할 수 있다.
  Info.prototype.printUser = function () {
    return `name:${this.name}/age:${this.age}`;
  };
  const kwon = new Info('kwon', 31);
  const kim = new Info('kim', 27);
  // 각각의 인스턴스는 다른 객체이다.
  // -> false
  console.log(kwon === kim);
  // 그러나 프로토타입 레벨의 함수는 공유되어 사용된다.
  // -> true
  console.log(kwon.printUser === kim.printUser);
  // 오버라이딩또한 가능하다.
  // -> 안녕하세요!! name:kwon/age:31
  kwon.printUser = function () {
    return `안녕하세요!! name:${this.name}/age:${this.age}`;
  };
}
```

각각의 인스턴스는 생성자 함수에 의해 prototype 속성을 상속받는다. 

![image-20220612224510412](/Users/khg/Library/Application Support/typora-user-images/image-20220612224510412.png)

##### 프로토타입 객체

프로토타입 객체란 객체지행 프로그래밍의 근간을 이루는 객첵 간 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 상위(부모)객체의 역할을 하는 객체로서 다른객체에 공유 프로퍼티를 제공한다. 프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.

- 모든 객체는 하나의 프로토타입을 갖는다. 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다



접근자 프로퍼티 `__proto__ `는 object.prototype의 프로퍼티다. 모든 객체는 상속을 통해 접근자 프로퍼티를 사용할 수 있다.

- get/set으로 이루어줘 있음

- Object.setPrototypeOf(obj, 상속받을 obj)을 통해 프로터타입을 교체 할 수 있다.

  

prototype 프로퍼티(속성)는 생성자 함수가 생성할 인스턴스 객체의 프로토타입을 가리킨다. **<u>따라서 생성자 함수만이 prototype을 소유한다.</u>**

|             구분             | 소유        | 값                | 사용주체    | 사용 목적                                                    |
| :--------------------------: | ----------- | ----------------- | ----------- | ------------------------------------------------------------ |
| `__proto__ ` 접근자 프로퍼티 | 모든객체    | 프로토타입의 참조 | 모든 객체   | 객체가 자신의 프로토타입에 접근 또는 교체하기 위해 사용      |
|      prototype 프로퍼티      | Constructor | 프로토타입의 참조 | 생성자 함수 | 생성자 함수가 자신이 생성할 객체 인스턴스의 프로토타입을 할당하기 위해 사용 |

모든 프로토타입은 constructor프로퍼티를 갖는다. 이 constructor 프로퍼티는 프로토타입 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.이 연결은 생성장 함수가 생성될 때, 즉 함수 객체가 생성될 때 이뤄진다.

- constructor가 가리키는 것은 생성자 함수이고, 생성자 함수는 인스턴스를 생성한 생성자 함수이다.

- 생성자 함수에는 자기자신의 프로퍼티가 정의되어 있고, 생성자함수에 의해 생성된 인스턴스는 prototype 프로퍼티을 통해 부모 속성을 사용할 수 있다.

리터럴 표기법으로 의해 생성된 객체는 생성자 함수로 생성된게 아닌다. 하지만 constructor와 연결되어 있다.

프로토타입 체인: 자바스크립트는 객체의 프로퍼티에 접근하려 할 때 해당 객체에 접근하려는 프로퍼타가 없다면, 내부슬롯 참조에 따라 자신의 부모 역할을 하는 프로퍼타입의 프로퍼티를 순차적으로 검색한다.

#### 정적 프로퍼티

생성자 함수 또한 객체임으로 자기자신의 속성값을 가질수 있다 이를 정적프로퍼티라 한다.인스턴스는 프로토타입 체인에 속하지 않는 정적메서드에는 접근이 불가하다.

```javascript
function testStatic(params) {
  function Obj(name) {
    const staticA = 'A';
    this.name = name;
  }
  Obj.staticB = 'B';
  const obj1 = new Obj('test1');
  // -> obj1.staticA:"undefined
  console.log(`obj1.staticA:"${obj1.staticA}`);
  // -> obj1.staticA:"undefined
  console.log(`obj1.staticb:"${obj1.staticB}`);
  // -> test1
  console.log(`obj1.staticb:"${obj1.name}`);
}
```

 

***

### 8.strice mode(엄격모드)

자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.

Eslint 같은 린트 도구를 사용해도 유사한 효과를 얻을 수 있다.린트 도구는 정적분석 기능을 통해 소스코드를 실행하기 전에 소스코드를 스캔하여 문법적 오류만이 아니라 잠재적 오류까지 찾아내고 오류의 원인을 리포팅해준다.





***

### 9.this 키워드

this는 자신이 속한 객체 또는 인스턴스를 가르키는 자기 참조 변수다.this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티와 메서드를 참조할 수 있다.this는 자바스크립트 엔진에 의해 암묵적으로 생성된다. 코드 어디서든 참조할 수 있다.`단 this가 가르키는 값, 즉 this의 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.`  

- 바인딩은 식별자와 값을 연결하는 과정이다.

  |        함수 호출 방식        |                      this가 가르키는것                       |
  | :--------------------------: | :----------------------------------------------------------: |
  |      일반 함수로서 호출      | 전역 객체 브라우저 환경: window/ node환경: global (엄격모드에서는 undefined다. ) |
  | 메서드로서 호출(객체 메서드) |                     메서드를 호출한 객체                     |
  |     생성자 함수로서 호출     |                생성자 함수가 생성할 인스턴스                 |

- this는 일반적으로 자기 참조 변수임으로, `strict mode가 적용된 일반 함수 내부의 this에서는 undefined가 반환된다.`  

#### 함수 호출방식과 this바인딩

this의 바인딩은 동적으로 결정된다.

- 렉시컬 스코프와 this바인딩의 결정시기는 다르다.

  - 렉시컬 스코프는 함수가 정의된곳 상위 스코프를 결정한다, 
  - 하지만 this 바인딩은 함수 호출 시점에 결정된다.
  - 런타임상 동적으로 바인딩된다.

- 일반 함수로 호출된 모든 함수(중첩함수,콜백함수) `내부의 this에는 전역 객체가 바인딩된다.`

- ```javascript
  var v = 100;
  function basicThis() {
    const obj = {
      v: 10,
      printV: function () {
        function innerF() {
          console.log(`중첨함수 에서 this는? ${this.v}`);
        }
        //일반함수로 호출 -> 전역변수 100
        innerF();
        console.log(`내부에서 this는? ${this.v}`);
      },
    };
    // 객체의 프로퍼티 메서드로 호출 ->10
    obj.printV();
  }
  basicThis();
  
  function dynamicBinding() {
    function Info(name) {
      this.name = name;
      this.printName = function () {
        console.log(`name:${this.name}`);
      };
    }
    const kwon = new Info('kwon');
    function printCallBack(callBack) {
      // -> name:undefined
      callBack();
    }
    printCallBack(kwon.printName);
  }
  ```
  
  ```javascript
  function bindThis() {
    const obj = {
      v: 10,
      t: 15,
      printV: function () {
        // 명시적으로 this를 바인딩.
        const that = this;
        function innerF() {
          // ->15
          console.log(`t는 ${that.t}`);
          // ->10
          console.log(`중첨함수 에서 this는? ${that.v}`);
        }
        innerF();
        console.log(`내부에서 this는? ${this.v}`);
      },
    };
    
    const obj1 = {
      v: 1,
      print() {
        // 화살표 함수 내부의 this는 상위 스코프의 this를 가르킨다.
        // 화살표 함수는 생성시 렉시컬 환경에서의 상위 this를 기억한다.
        setTimeout(() => console.log(this.v), 10);
      },
    };
    
    const obj2 = {
      v: 1,
      print() {
        // 바인드를 통해 this를 연결한다.
        setTimeout(
          function () {
            console.log(this.v);
          }.bind(this),
          10,
        );
      },
    };
    
    function Info(name) {
      this.name = name;
      this.printName = function () {
        console.log(`name:${this.name}`);
      };
      // 바인드를 통해 this를 연결한다.
      this.printName = this.printName.bind(this);
    }
    const kwon = new Info('kwon');
    function printCallBack(callBack) {
      callBack();
    }
    printCallBack(kwon.printName);
  }
  ```
  
- 

#### 동적으로 바인딩되는 This를 방지

- 객체의 메서드로 정의
  - 메서드 내부에서 this는 메서드를 호출한 객체를 가르킴
  - 즉 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩 된다.

- 화살표 함수로 정의
  - Apply,bind,call을 사용하여 명시적으로 바인딩 할 수 있다.


### 10.클래스

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/class

자바스크립트는 프로토타입 기반 객체지향 언어이다. 클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만, 클래스는 생성자 함수보다 엄격하며 생성자 함수에서는 제공하지 않는 기능도 제공한다.

- new 연산자 없이 호출하면 에러발생
- 상속을 지원하는 extends와 super키워드를 제공
- 클래스는 호이스팅이 발생하지 않는것 처럼 동작한다.
- 암묵적으로 엄격모드가 적용된다.
- 클래싀의 생성자,프로토타입메서드,정적메서드는 모두 프로퍼티를 열거 할 수 없다.

#### 클래스 정의

클래스는 함수이며, 일급객체로 사용할 수 있다.

클래스 선언문으로 정의한 클래스는 함수 선운문과 같이 소스코드 평과 과정, 즉 런타임 이전 먼저 평가되어 함수 객체를 생성한다.

- 무명의 리터럴로 생성할 수 있다. 즉 런타임에 생성이 가능하다.
- 변수나 자료구조(객체,배열)에 저장할 수 있다.
- 함수의 매개변수에 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.

모든 함수객체가 가지고 있는 prototype 프로퍼티가 가리키는 프로토타입 객체의 constructor 프로퍼티 클래스 자신을 가르키고 있다.이는 클래스가 인스턴스를 생성하는 생성자 함수라는 것을 의미한다.

this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체를 가르킨다.

- 인스턴스의 프로퍼티를 사용할 경우 프로퍼티 레벨의 함수를 선언
- 만약 this를 사용하지 않을 경우 정적메서드로 정의

```javascript
function basicCalss(params) {
  // 생성자 함수 new키워드로 호출할대 생성되는 함수\
  class Info {
    // 클레스 레벨의 변수를 선얼할대는 static을 사용
    // 정적 변수
    static DESC = 'This is Info Class';
    // 접근 제어자 - 캡슐화
    // private(#) , public(기본), protected
    // private는 클래스 내부에서 만 사용
    #name;
    #age;
    // 생성자
    // 인스턴스 생성 및 초기화
    // constructor 암뭉적으로 this를 반환한다.
    // return this
    constructor(name, age) {
      this.#name = name;
      this.#age = age;
    }

    // 클래스 필드정의
    // 클래스 필드에 함수를 정의 할경우 인스턴스 레벨의 메서드이다.
    print = () => console.log(`name:${this.name}age:${this.age}`);
    getName = function () {
      return this.name;
    };
    // 프로토타입 레벨의 메서드
    print() {
      console.log(`name:${this.name}age:${this.age}`);
    }
  }

  const o1 = new Info('kown', 31);
  // 클레스 레벨의 변수는 인스턴스에서 사용 불가.
  // -> undefined
  console.log(o1.DESC);
  // Info { print: [Function: print], getName: [Function: getName] }
  console.log(o1);
  // console.log(o1.print());
}
```

```javascript
function getsetClass() {
  class Info {
    constructor(name, age) {
      this.name = name;
      this.age = age;
    }
    printInfo() {
      console.log(`name:${this.name}age:${this.age}`);
    }

    get ageInfo() {
      return this.name;
    }
    set ageInfo(age) {
      this.age = age;
    }
  }
  const kwon = new Info('kwon', 31);
  kwon.ageInfo = 25;
  console.log(kwon.ageInfo);
  console.log(Object.getOwnPropertyDescriptor(kwon));
}
// getsetClass();
function extendClass(params) {
  class Polygon {
    constructor(height, width, dimension) {
      this.name = 'Polygon';
      this.type = 'Figure';
      this.height = height;
      this.width = width;
      this.dimension = dimension;
      // this는 호출한 인스턴스가 가지고 있음.
      console.log(this);
    }
    calArea() {
      return this.height * this.width * this.dimension;
    }
    toString() {
      return this.name;
    }
  }

  class Square extends Polygon {
    static #D = 1;
    // new생성자 함께 클래스를 호출 할때 전달할 인수의 리스트.
    constructor(height, width) {
      // 수퍼클래스의 constructor를 호출하여 인스턴스를 생성 및 반환
      // super를 참조하면 수퍼클래스의 메서드를 호출 할 수 있다.
      super(height, width, Square.#D);
      this.name = 'Square';
      console.log(this);
    }
    // 오버로딩
    toString() {
      // 서브 클래스 메서드에서만 슈퍼클래스의 메서드를 참조 할 수 있다.
      // [[HomeObject]]를 가지는 함수
      console.log(super.toString());
      return super.toString() + this.height;
    }
  }
  const s1 = new Square(15, 15);
  console.log(s1);
  console.log(s1.calArea());
  console.log(s1.toString());
}
```























***



### 기타정리 부분

#### 1.래퍼객체

문자열,불리언,숫자 등의 원시값에 문자열,숫자,블리언 객체를 생성하는 표준빑트인 생성자 함수가 있는이유?

- ```javascript
  function basicWraper(params) {
    const str = 'string?';
    //->7
    console.log(str.length);
    // ->STRING?
    console.log(str.toUpperCase());
  }
  ```

- 원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근허거나 메서드를 호출하고 다시 원시값으로 되돌린다.
- 이처럼 문자열,불리언,숫자 값에 대해 객체처럼 접근하면 생성되는 객체를 임시객체(래퍼객체)라 한다.

#### 2.전역객체

전역객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 가장 먼저 생성되는 특수한 객치에디.

- 브라우저 환경에서 전역객체

  - window,this,self,frames

- 노드 환경에서 전역객체

  - this.global

- 전역객체는 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체의 최상위 객체이다.

  - 이는 프로퍼타입 상속 관계상에서 최상위 객체라는 의미가 아니라, 계층적 구조상 표준 빑트인 객체와 호스트 객체를 프로퍼티로 소유한다는 것을 의미한다.

- 전역객체는 의도적으로 생성할 수 없다.

- 참조시 window,global등의 생략이 가능하다.

- 표준빌트인 객체를 프로퍼티로 가지고 있다.

- var키워드, 전역 함수는 전역 객체의 프로퍼티가 된다.

- Let,const는 전역객체의 프로퍼티가 아니다.이는 전역 레시컬 환경의 선언적 환경레코드 내에 존재한다.

- ```javascript
  var foo = 'foo';
  function basicWraper(params) {
    const str = 'string?';
    // console.log(str.length);
    // console.log(str.toUpperCase());
    // 해당 코드가 실행되면 암묵적전역으로 전역객체의 프로퍼티가 된다.
    y = 10;
  }
  basicWraper();
  // 브라우저에서는 window.foo가 출력됨.
  console.log(window.foo);
  // 암묵적 전역
  // 브라우저에서는 10이 출력된다.
  console.log(y);
  ```

  



