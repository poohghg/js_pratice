## React 간략정리

###  Virtual DOM

상태에 따라 Dom구조가 변경되면 Reflow, Repaint 과정이 일어난다.

> **레이아웃**을 만들고 **페인팅을 하는 과정**이 다시 **반복**되는 것을 알 수 있었다. 즉, **브라우저가 연산을 많이 해야한다**는 이야기이며, 전체적인 프로세스를 **비효율적**으로 만든다는 것이다.

하지만 react의 Dom업데이트 방식은 Virtual DOM을 사용해 발생한다. 리액트는 실제 Dom과 같은 Virtual DOM을 생성하고 상태에 따라 변경된 Dom의 부분만 배치 처리하려 한번에 변경한다.

- 이때 기존의 Dom의 변경부분을 파악하는데 사용되는 알고리즘이 **diffing 알고리즘** 이다.
  - diff알고리즘
  - 서로 다른 타입의 두 엘리먼트는 서로 다른 트리를 만들어 낸다.
  - 개발자가 **key prop**을 통해 컴포넌트 인스턴스를 식별하여, 여러 렌더링 사이에서 어떤 자식 엘리먼트가 변경되지 않아야할지 표시해 줄 수 있다.

##### diff알고리즘

- 성능상의 이점을 가져오기 위해 사용
  - 변경된 속성이나 태그에 대해 업데이트 하는 과정이 필요
- node의 추가/제거 된상태를 인지
- node의 태그 이름(type)이나 속성이 변경되 부분만 인지하여 변경

> ### Keys
>
> 이러한 문제를 해결하기 위해, React는 `key` 속성을 지원합니다. 자식들이 key를 가지고 있다면, React는 key를 통해 기존 트리와 이후 트리의 자식들이 일치하는지 확인합니다. 예를 들어, 위 비효율적인 예시에 `key`를 추가하여 트리의 변환 작업이 효율적으로 수행되도록 수정할 수 있습니다.

> 출처
>
> https://ko.reactjs.org/docs/reconciliation.html

### 불변성을 지키는 이유

#### 1) 리액트의 state 변화 감지 기준은 "콜스택의 주소값"이다.

리액트는 콜스택의 주소값만을 비교하여 상태 변화를 감지한다.이를 "얕은 비교"라고 한다. 리액트의 빠른 state 변화 감지를 할 수 있도록 해주는 장점이자, 불변성을 지켜야하는 이유이다.

원시타입의 변화의 메모리 영역값이 변경하지 않는, 불변성을 유지한채로 새로운 메모리 영역에서 변경된 값이 저장 되기 때문에 콜스택 의 주소값의 변화가 감지되지만,

참조 타입은 콜스택에 메모리 힙의 주소만을 저장하고, 값은 메모리 힙에 저장,변경되기 때믄에 참조 타입의 값을 변경하면 **콜스택의 주소값은 변경이 없어 react는 state의 변경이 없다고 감지**하기 때문에 변경된 **state는 리랜더링되지 않는다**.

따라서 참조타입의 변경된 값을 react가 감지 할 수 있도록 불변성을 유지해야한다

> 불변성이란? 원시타입의 변수는 변수값이 변경되면 기존 콜스택의 메모리 영역의 value를 변경하지 않고 (메모리 영역의 값을 변경할 수 없는 것을 **"불변성"**이라고 한다.) 새로운 메모리 영역에 변경된 변수값을 저장한다.
>
> \* 더 이상 참조되지 않는 데이터는 가비지 컬렉터에 의해 적절한 시점에 메모리에서 해제된다.
>
> "불변성의 진짜 의미는 **메모리 영역에서 값을 변경할 수 없다**는 의미입니다."

### 리렌더링

리액트 컴퍼넌터들은 초기 마운시 렌더링후 상태 변경에 따라 새로운 상태를 렌더링한다

렌더링이 발생되는 상황

- 내부 상태(state) 변경시
- 부모에게 전달받은 값(props) 변경시
- 중앙 상태값(Context value 혹은 redux store) 변경시
- 부모 컴포넌트가 리렌더링 되는 경우
- this.forceUpdate로 강제로 렌더링을 트리거할 때



1. 위의 조건을 통해 컴포넌트 리렌더링
2. 구현부 실행 = props 취득, hook 실행, 내부 변수 및 함수 재 생성
3. return 실행, 렌더링 시작
4. 렌더 단계(Render Phase): 새로운 가상 DOM 생성 후 이전 가상 DOM과 비교해 달라진 부분을 탐색하고 실제 DOM에 반영할 부분을 결정
5. 커밋 단계(Commit Phase): 달라진 부분만 실제 DOM에 반영
6. useLayoutEffect: 브라우저가 화면에 Paint하기 전에 useLayoutEffect에 등록해둔 effect(부수 효과 함수)가 동기적으로 실행되며, 이때 state, redux store 등의 변경이 있다면 한번 더 리렌더링
7. Paint: 브라우저가 실제 DOM을 화면에 그림. didUpdate 완료.
8. useEffect: update되어 화면에 그려진 직후, useEffect에 등록해둔 effect(부수 효과 함수)가 비동기로 실행



### FLUX

<img src="https://github.com/poohghg/prepare_frontend_interview/raw/main/images/flux1.PNG" alt="FLUX 패턴" style="zoom:50%;" />





- FLUX는 추상적인 개념이다. 
- 패턴에서는 단방향 데이터 흐름을 강조한다.

> 사용자의 행위 `액션`은 `디스패쳐`에 의해 통제됩니다. `디스패처`가 `스토어`를 업데이트하고 변경된 `스토어`에 대한 `뷰`를 리렌더링합니다.
>
> `뷰`에서는 `스토어`에 직접 접근하지 않으며, `디스패처`로 다시 액션을 보내고 `스토어`를 업데이트한 뒤, 다시 `뷰`를 리렌더링하는 단방향적 구조를 가집니다.
>
> `FLUX` 패턴은 이러한 단방향적인 데이터 흐름 구조를 통해 어떤 액션이 디스패처에 의해 어떤 결과를 낳고 변화되는지 명확히 파악하고 알아볼 수 있습니다.
